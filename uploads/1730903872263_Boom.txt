Vậy dựa vào code này của tôi, bạn hiểu những gì
Client

App.jsx
import React, { useState, useEffect } from 'react';
import {
  Moon,
  Sun,
  Phone,
  Video,
  Info,
  Search,
  Archive,
  Users,
  MessageCircle,
  Send,
  Menu,
} from 'lucide-react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import NavBar from './NavigationBar';
import ChatLayout from './pages/Chat/ChatLayout';

import { HashRouter as Router, Routes, Route, Navigate } from 'react-router-dom'; // Đảm bảo có Navigate

import {user,messages} from './Mockdata';
import VideoCall from './pages/Call/VideoCall';
import MeetingRoom from './pages/Meeting/MeetingRoom';
import MeetingPage from './pages/Meeting/MeetingPage';
import ReactLogo from './assets/ok.jpg'; // Đảm bảo đường dẫn chính xác
import DocumentsPage from './pages/Documents/DocumentsPage';
import Auth from './pages/Login/Auth';
import io from 'socket.io-client'; // Import socket.io-client

const socketServerURL = 'http://172.20.10.4:3009'; // Địa chỉ server Socket.io
export default function MessengerInterface() {
  const [chats, setChats] = useState([]);

  useEffect(() => {
    const fetchFriendRequests = async () => {
      try {
        const user = JSON.parse(localStorage.getItem('user'));
        const userId = user ? user.id : null;
  
        if (!userId) {
          throw new Error('User is not authenticated');
        }
  
        const response = await fetch(${socketServerURL}/friends/requests?userId=${userId}, {
          method: 'GET',
          headers: {
            Authorization: Bearer ${localStorage.getItem('token')},
          },
        });
  
        if (!response.ok) {
          throw new Error('Failed to fetch friend requests');
        }
  
        const requests = await response.json();
        setChats(requests.map(req => ({
          id: req.id,
          user_id: req.user_id,
          friend_id: req.friend_id,
          name: req.userDetail ? req.userDetail.username : 'Unknown', // Lấy thông tin từ userDetail
          status: req.status,
        })));
      } catch (error) {
        console.error('Error fetching friend requests:', error);
      }
    };
  
    fetchFriendRequests();
  }, []);
  

  
  

  const handleAccept = async (id) => {
    try {
      const chat = chats.find(chat => chat.id === id);
      
      if (!chat) {
        throw new Error('Friend request not found');
      }
  
      const user = JSON.parse(localStorage.getItem('user'));
      const userId = user ? user.id : null;
  
      if (!userId) {
        throw new Error('User is not authenticated');
      }
  
      console.log("User ID:", userId);
      console.log("Friend ID:", chat.friend_id); // Sử dụng friend_id thay vì user_id
  
      const response = await fetch(${socketServerURL}/friends/accept, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: Bearer ${localStorage.getItem('token')},
        },
        body: JSON.stringify({
          userId: userId,          // ID của người chấp nhận yêu cầu (người đăng nhập)
          friendId: chat.user_id   // ID của người gửi yêu cầu (bạn bè)
        }),
      });
  
      if (!response.ok) {
        const errorResponse = await response.json();
        throw new Error(Failed to accept friend request: ${errorResponse.message});
      }
  
      const result = await response.json();
      console.log(result.message);
  
      setChats(prevChats => prevChats.filter(chat => chat.id !== id));
    } catch (error) {
      console.error('Error accepting friend request:', error);
    }
  };
  
  
  
  

  const handleDecline = async (id) => {
    try {
      const chat = chats.find(chat => chat.id === id);
      
      if (!chat) {
        throw new Error('Friend request not found');
      }
  
      const user = JSON.parse(localStorage.getItem('user'));
      const userId = user ? user.id : null;
  
      if (!userId) {
        throw new Error('User is not authenticated');
      }
  
      const response = await fetch(${socketServerURL}/friends/decline, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: Bearer ${localStorage.getItem('token')},
        },
        body: JSON.stringify({
          userId: userId,           // ID của người dùng hiện tại (người nhận yêu cầu)
          friendId: chat.user_id    // ID của người gửi yêu cầu kết bạn
        }),
      });
  
      if (!response.ok) {
        throw new Error('Failed to decline friend request');
      }
  
      setChats(prevChats => prevChats.filter(chat => chat.id !== id));
    } catch (error) {
      console.error('Error declining friend request:', error);
    }
  };
  

  
  const [selectedChat, setSelectedChat] = useState(chats[0]);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [showRightSidebar, setShowRightSidebar] = useState(false);
  const [showMenuSidebar, setShowMenuSidebar] = useState(false);
  const [activeTab, setActiveTab] = useState('messages'); // Default tab is 'messages'
  const [isAuthenticated, setIsAuthenticated] = useState(!!localStorage.getItem('token'));
  const [socket, setSocket] = useState(null); // State để lưu socket instance
  const user = JSON.parse(localStorage.getItem('user')); // Lấy thông tin người dùng từ local storage
  const userName = user ? user.username : "Guest"; // Lấy tên người dùng hoặc hiển thị "Guest"
  const userId = user ? user.id : null; // Lấy ID người dùng
  const handleLogin = (token) => {
    localStorage.setItem('token', token); // Lưu token vào Local Storage
    setIsAuthenticated(true); // Cập nhật trạng thái xác thực
    const socketConnection = io(socketServerURL, {
      auth: { token }, // Gửi token khi kết nối
    });

    socketConnection.on('connect', () => {
      console.log('Connected to socket server');
    });

    socketConnection.on('disconnect', () => {
      console.log('Disconnected from socket server');
    });

    setSocket(socketConnection); // Lưu socket instance
  };
  //
  useEffect(() => {
    // Đếm số phần tử có status là 'accepted' và cập nhật friendRequests
    const countStatusZero = chats.filter((chat) => chat.status === 'accepted').length;
    setFriendRequests(countStatusZero);
  }, [chats]);

  const [friendRequests, setFriendRequests] = useState(); // Number of friend requests

  const [friends, setFriends] = useState([]);

// useEffect để lấy danh sách bạn bè sau khi component mount
useEffect(() => {
  const fetchFriendsList = async () => {
    try {
      const response = await fetch(${socketServerURL}/friends/list?userId=${userId}, {
        method: 'GET',
        headers: {
          Authorization: Bearer ${localStorage.getItem('token')},
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch friends list');
      }

      const friendsList = await response.json();
      setFriends(friendsList.map(friend => ({
        id: friend.id,
        name: friend.friendDetail.username, // Dùng alias friendDetail từ API
        email: friend.friendDetail.email,
      })));
    } catch (error) {
      console.error('Error fetching friends list:', error);
    }
  };

  if (userId) {
    fetchFriendsList();
  }
}, [userId]);

//đổi màu
  useEffect(() => {
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);
//set để nút đổi màu
  const toggleDarkMode = () => {
    setIsDarkMode(!isDarkMode);
  };
// bật tắt navbar
  const toggleRightSidebar = () => {
    setShowRightSidebar(!showRightSidebar);
  };
  
  
  const toggleMenuSidebar = () => {
    setShowMenuSidebar(!showMenuSidebar);
  };
  const [allUsers, setAllUsers] = useState([]); // State để lưu danh sách tất cả người dùng

//lấy tất cả users
useEffect(() => {
  const fetchUsers = async () => {
    try {
      const response = await fetch(${socketServerURL}/api/users, {
        headers: {
          Authorization: Bearer ${localStorage.getItem('token')}
        }
      });

      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }

      const users = await response.json();
      setAllUsers(users);
    } catch (error) {
      console.error('Error fetching users:', error);
    }
  };

  if (activeTab === 'archive') {
    fetchUsers();
  }
}, [activeTab]);
//render phần search
const [searchQuery, setSearchQuery] = useState('');

//GỬi LMKB
const sendFriendRequest = async (friendId) => {
  try {
    // Lấy ID người dùng từ localStorage
    const user = JSON.parse(localStorage.getItem('user')); 
    const userId = user ? user.id : null; // Lấy ID người dùng từ localStorage

    const response = await fetch(${socketServerURL}/friends/request, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: Bearer ${localStorage.getItem('token')},
      },
      body: JSON.stringify({ userId: userId, friendId: friendId }), // userId là ID của người gửi yêu cầu, friendId là ID của bạn
    });

    if (!response.ok) {
      throw new Error('Failed to send friend request');
    }

    const result = await response.json();
    console.log('Friend request sent:', result);
  } catch (error) {
    console.error('Error sending friend request:', error);
  }
};


const renderTabContent = () => {
  switch (activeTab) {
    case 'archive':
      const filteredUsers = allUsers.filter(user =>
        user.username.toLowerCase().includes(searchQuery.toLowerCase())
      );
      return (
        <div className="overflow-y-auto flex-1 p-4">
          <h2 className="text-2xl font-semibold text-center dark:text-white mb-6">
            All Users
          </h2>

          {filteredUsers.map((user) => (
            <div key={user.id} className="flex flex-col sm:flex-row items-center sm:items-start p-6 bg-white dark:bg-gray-800 rounded-xl mb-5 shadow-lg transition-all hover:bg-gray-50 dark:hover:bg-gray-700 space-y-4 sm:space-y-0 sm:space-x-6">
              {/* Nội dung hiển thị thông tin người dùng */}
              <Avatar className="w-20 h-20 rounded-full shadow-md flex-shrink-0">
                <AvatarImage src={ReactLogo} alt={user.username} />
                <AvatarFallback>{user.username.charAt(0)}</AvatarFallback>
              </Avatar>
              <div className="flex-1 text-center sm:text-left">
                <span className="text-xl font-medium dark:text-white block mb-2">
                  {user.username}
                </span>
                <button className="bg-green-500 text-white px-6 py-2 rounded-lg hover:bg-green-600 transition-all text-sm w-full sm:w-auto" onClick={() => sendFriendRequest(user.id)}>
                  Add Friend
                </button>
              </div>
            </div>
          ))}
        </div>
      );

      case 'users':
        return (
          <div className="overflow-y-auto flex-1 p-4">
            <h2 className="text-2xl font-semibold text-center dark:text-white mb-6">
              Friend Requests
            </h2>

            {/* Kiểm tra nếu không có yêu cầu kết bạn */}
            {chats.length === 0 ? (
              <p className="text-center text-gray-500 dark:text-gray-400">
                No friend requests available.
              </p>
            ) : (
              chats.map((chat) => (
                <div
                  key={chat.id}
                  className="flex flex-col sm:flex-row items-center sm:items-start p-6 bg-white dark:bg-gray-800 rounded-xl mb-5 shadow-lg transition-all hover:bg-gray-50 dark:hover:bg-gray-700 space-y-4 sm:space-y-0 sm:space-x-6"
                >
                  <Avatar className="w-20 h-20 rounded-full shadow-md flex-shrink-0">
                    <AvatarImage src={ReactLogo} alt={chat.name} />
                    <AvatarFallback>{chat.name ? chat.name.charAt(0) : '?'}</AvatarFallback>
                  </Avatar>
                  <div className="flex-1 text-center sm:text-left">
                    <span className="text-xl font-medium dark:text-white block mb-2">
                      {chat.name}
                    </span>
                    <div className="flex flex-col sm:flex-row sm:space-x-4 space-y-3 sm:space-y-0 mt-2">
                      {/* Button Accept */}
                      <button
                        className="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 transition-all text-sm w-full sm:w-auto"
                        onClick={() => handleAccept(chat.id)}
                      >
                        Accept
                      </button>

                      {/* Button Decline */}
                      <button
                        className="bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-white px-6 py-2 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition-all text-sm w-full sm:w-auto"
                        onClick={() => handleDecline(chat.id)}
                      >
                        Decline
                      </button>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        );


        case 'messages':
      default:
        // Hiển thị danh sách bạn bè
        const filteredFriends = friends.filter(friend =>
          friend.name.toLowerCase().includes(searchQuery.toLowerCase())
        );
        return (
          <div className="overflow-y-auto flex-1">
            {filteredFriends.map((friend) => (
              <div
                key={friend.id}
                className={flex items-center p-4 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-800 cursor-pointer transition-all ${
                  selectedChat && selectedChat.id === friend.id ? 'bg-blue-100 dark:bg-blue-900' : ''
                }}
                onClick={() => setSelectedChat(friend)}
              >
                <Avatar className="w-12 h-12 mr-4 shadow-md dark:shadow-gray-700">
                  <AvatarImage src={ReactLogo} alt={friend.name} />
                  <AvatarFallback>{friend.name.charAt(0)}</AvatarFallback>
                </Avatar>
                <div className="flex-1">
                  <div className="flex justify-between items-center">
                    <h2 className="font-semibold dark:text-white">{friend.name}</h2>
                    <span className="text-sm text-gray-500 dark:text-gray-400">{friend.email}</span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        );
          
    }
};

  return (
    <Router>
      <div className="flex h-screen bg-white dark:bg-gray-900 transition-colors  duration-200">
          {/* Menu Sidebar */}
          <div
            className={fixed top-0 left-0 h-full w-64 z-50 bg-gray-100 dark:bg-gray-800 shadow-lg border-r border-gray-300 dark:border-gray-700 transition-transform transform ${
              showMenuSidebar ? 'translate-x-0' : '-translate-x-full'
            }}
          >
            <NavBar toggleMenuSidebar={toggleMenuSidebar} />
          </div>
          {showMenuSidebar && (
          <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40"
          onClick={toggleMenuSidebar}
        ></div>
          )}
        {/*RouterPage*/}

          

          <Routes>
            <Route path='/' element={<Auth onLogin={handleLogin} />} />
            <Route
              path="/chat"
              element={isAuthenticated ? (
                <ChatLayout
                selectedChat={selectedChat}
                setSelectedChat={setSelectedChat}
                chats={chats}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}
                toggleMenuSidebar={toggleMenuSidebar}
                setActiveTab={setActiveTab}
                activeTab={activeTab}
                friendRequests={friendRequests}
                renderTabContent={renderTabContent}
                showRightSidebar={showRightSidebar}
                toggleRightSidebar={toggleRightSidebar}
                searchQuery={searchQuery} // Truyền searchQuery vào ChatLayout
                setSearchQuery={setSearchQuery} // Truyền setSearchQuery vào ChatLayout
                />
              ) : (
                <Navigate to="/" replace /> // Chuyển hướng đến trang đăng nhập nếu chưa đăng nhập
              )}
            />
            <Route path="/meeting" element={ isAuthenticated ? (
              <MeetingPage 
                toggleMenuSidebar={toggleMenuSidebar}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}
                userName = {userName}
              />
              
            ) : (
              <Navigate to="/" replace /> // Chuyển hướng đến trang đăng nhập nếu chưa đăng nhập
            )} />
            <Route path="/meeting/:roomId" element={isAuthenticated ? (
                <VideoCall />
              ) : (
                <Navigate to="/" replace />
              )} />
            <Route path="/document" element={ isAuthenticated ? (
              <DocumentsPage
                toggleMenuSidebar={toggleMenuSidebar}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}

                setSelectedChat={setSelectedChat}
              />
            ) : (
              <Navigate to="/" replace /> // Chuyển hướng đến trang đăng nhập nếu chưa đăng nhập
            )}>

            </Route>

          </Routes>
      </div>
    </Router>
  );
}

Auth.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom'; // Import useNavigate

function AuthPage({ onLogin }) {
  const [isLogin, setIsLogin] = useState(true); // Quản lý trạng thái đăng nhập/đăng ký
  const toggleAuthMode = () => setIsLogin(!isLogin); // Chuyển đổi giữa đăng nhập và đăng ký

  return (
    <div className="w-full p-6 space-y-6 bg-white dark:bg-gray-800 shadow-md rounded-lg" style={{ margin: 'auto', width: '400px' }}>
      <h2 className="text-center text-2xl font-bold text-gray-800 dark:text-white">
        {isLogin ? 'Login' : 'Register'}
      </h2>

      {isLogin ? <LoginForm onLogin={onLogin} /> : <RegisterForm />}

      <p className="text-center text-sm text-gray-600 dark:text-gray-400">
        {isLogin ? "Don't have an account?" : 'Already have an account?'}{' '}
        <button onClick={toggleAuthMode} className="font-medium text-blue-500 hover:underline">
          {isLogin ? 'Register' : 'Login'}
        </button>
      </p>
    </div>
  );
}

function LoginForm({ onLogin }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const navigate = useNavigate(); // Khởi tạo useNavigate
  const socketServerURL ='http://172.20.10.4:3009'
  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch(${socketServerURL}/api/login, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error('Login failed!');
      }

      const data = await response.json();
      console.log('Login successful:', data);

      // Lưu token và thông tin người dùng vào local storage
      localStorage.setItem('token', data.token);
      localStorage.setItem('user', JSON.stringify(data.user)); // Lưu thông tin người dùng

      // Gọi hàm onLogin để cập nhật trạng thái xác thực trong App
      onLogin(data.token);

      // Điều hướng đến main page sau khi đăng nhập
      navigate(/chat?token=${data.token}); // Thêm token vào URL
    } catch (error) {
      console.error('Error during login:', error);
      setMessage('Login failed. Please check your email and password.');
    }
  };

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      {message && <p className="text-red-500 text-sm">{message}</p>}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Email</label>
        <input
          type="email"
          required
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Password</label>
        <input
          type="password"
          required
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <button
        type="submit"
        className="w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600"
      >
        Login
      </button>
    </form>
  );
}

function RegisterForm() {
  const [username, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const navigate = useNavigate(); // Khởi tạo useNavigate

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch(${socketServerURL}/api/users, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, email, password }),
      });

      if (!response.ok) {
        throw new Error('Registration failed!');
      }

      const data = await response.json();
      console.log('Registration successful:', data);
      setMessage('Registration successful! Redirecting to login...');

      // Chuyển hướng đến trang đăng nhập sau khi đăng ký thành công
      setTimeout(() => {
        navigate('/');
      }, 2000);
    } catch (error) {
      console.error('Error during registration:', error);
      setMessage('Registration failed. Please try again.');
    }
  };

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      {message && <p className="text-red-500 text-sm">{message}</p>}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Name</label>
        <input
          type="text"
          required
          value={username}
          onChange={(e) => setName(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Email</label>
        <input
          type="email"
          required
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Password</label>
        <input
          type="password"
          required
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <button
        type="submit"
        className="w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600"
      >
        Register
      </button>
    </form>
  );
}

export default AuthPage;

RightSideBar.jsx
import React from 'react';
import {
  Avatar,
  AvatarFallback,
  AvatarImage
} from '@/components/ui/avatar';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger
} from '@/components/ui/tabs';

function RightSidebar({ selectedChat}) {
  return (
    <div className="w-64 border-l border-gray-200 dark:border-gray-700 p-4 transition-transform transform">
      <Tabs defaultValue="info">
        <TabsList className="grid dark:text-white w-full grid-cols-2">
          <TabsTrigger value="info">Info</TabsTrigger>
          <TabsTrigger value="files">Files</TabsTrigger>
        </TabsList>

        {/* Tab Content for Info */}
        <TabsContent value="info" className="mt-4">
          <div className="text-center">
            <Avatar className="w-20 h-20 dark:text-white mx-auto shadow-md dark:shadow-gray-700">
              <AvatarImage src={/placeholder.svg?height=80&width=80} alt={selectedChat?.name} />
              <AvatarFallback>{selectedChat?.name.charAt(0)}</AvatarFallback>
            </Avatar>
            <h3 className="mt-2 font-semibold dark:text-white">{selectedChat?.name}</h3>
            <p className="text-sm text-gray-500 dark:text-gray-400">Active 2h ago</p>

            {/* Button to create group */}
            <button
              onClick={() => handleCreateGroup(selectedChat?.name)}
              className="mt-4 px-4 py-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 dark:text-black dark:bg-white dark:hover:bg-blue-500"
            >
              Create Group with {selectedChat?.name}
            </button>
          </div>
        </TabsContent>

        {/* Tab Content for Files */}
        <TabsContent value="files" className="mt-4">
          <p className="text-center text-gray-500 dark:text-gray-400">No files shared yet</p>
        </TabsContent>
      </Tabs>
    </div>
  );
}

export default RightSidebar;


MainChat.jsx
import React from 'react';
import { Phone, Video, Info, Send } from 'lucide-react';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';

function MainChat({ selectedChat, toggleRightSidebar }) {
  // Dữ liệu giả của tin nhắn
  const messages = [
    { sender: 'A', message: 'Hello, how are you?', timestamp: '10:00 AM' },
    { sender: 'B', message: 'I am fine, thank you! And you?', timestamp: '10:02 AM' },
    { sender: 'A', message: 'Doing well, thanks for asking!', timestamp: '10:03 AM' },
  ];

  return (
    <div className="flex-1 flex flex-col">
      {selectedChat && (
        <>
          {/* Header Section */}
          <div className="p-4 flex justify-between items-center border-b border-gray-300 dark:border-gray-700">
            <div className="flex items-center">
              <Avatar className="w-10 h-10 mr-3 dark:shadow-gray-700 dark:text-white shadow-md">
                <AvatarImage src={/placeholder.svg?height=40&width=40} alt={selectedChat.name} />
                <AvatarFallback>{selectedChat.name.charAt(0)}</AvatarFallback>
              </Avatar>
              <div>
                <h2 className="font-semibold dark:text-white">{selectedChat.name}</h2>
                <p className="text-sm text-gray-600 dark:text-gray-400">Online</p>
              </div>
            </div>
            <div className="flex space-x-4">
              <Phone className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors" />
              <Video className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors" />
              <Info
                className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors"
                onClick={toggleRightSidebar}
              />
            </div>
          </div>

          {/* Chat Messages Section */}
          <div className="flex-1 p-4 space-y-4">
            {messages.map((msg, index) => (
              <div
                key={index}
                className={flex ${msg.sender === 'A' ? 'justify-start' : 'justify-end'}}
              >
                <div className={p-3 rounded-lg ${msg.sender === 'A' ? 'bg-gray-200' : 'bg-blue-500 text-white'}}>
                  <p className="text-sm">{msg.message}</p>
                  <p className="text-xs text-gray-500">{msg.timestamp}</p>
                </div>
              </div>
            ))}
          </div>

          {/* Input Section */}
          <div className="p-4 border-t border-gray-300 dark:border-gray-700">
            <div className="flex items-center">
              <input
                type="file"
                id="file-upload"
                className="hidden"
                onChange={(e) => handleFileUpload(e)}
              />
              <label
                htmlFor="file-upload"
                className="m-2 p-2 bg-gray-300 dark:bg-white text-white dark:text-black rounded-full shadow-md hover:opacity-90 transition-opacity cursor-pointer"
              >
                <span className="w-5 h-5">📎</span>
              </label>
              <input
                type="text"
                placeholder="Type a message..."
                className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:text-white"
              />
              <button className="ml-2 p-2 bg-blue-500 dark:bg-white text-white dark:text-black rounded-full shadow-md hover:opacity-90 transition-opacity">
                <Send className="w-5 h-5" />
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}

export default MainChat;

LeftSideBar.jsx
import React from 'react';
import {
  Menu,
  Sun,
  Moon,
  Search,
  Archive,
  Users,
  MessageCircle,
} from 'lucide-react';

function LeftSideBar({ 
  isDarkMode, 
  toggleDarkMode, 
  toggleMenuSidebar, 
  setActiveTab, 
  activeTab, 
  friendRequests, 
  renderTabContent,
  title='Chats' ,
  searchQuery,
  setSearchQuery,
  sendFriendRequest
}) {
  return (
    <div className="w-1/3 border-r border-gray-300 dark:border-gray-700 flex flex-col">
      {/* Header Section */}
      <div className="p-4 flex justify-between items-center border-b border-gray-300 dark:border-gray-700 shadow-md dark:shadow-gray-700">
        <div className="flex items-center space-x-3">
          <Menu
            className="w-5 h-5 sm:w-6 sm:h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-blue-500 dark:hover:text-blue-400 transition-all duration-200"
            onClick={toggleMenuSidebar}
          />
          <h1 className="text-base sm:text-lg md:text-2xl font-bold text-gray-800 dark:text-gray-200 ">{title}</h1>
        </div>
        <div className="flex items-center space-x-2">
          <button
            className="flex items-center justify-center p-1 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-all duration-200"
            onClick={toggleDarkMode}
          >
            {isDarkMode ? (
              <Sun className="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-yellow-500" />
            ) : (
              <Moon className="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-gray-600 dark:text-gray-400" />
            )}
          </button>
        </div>
      </div>

      {/* Search Section */}
      <div className="p-4 border-b border-gray-300 dark:border-gray-700">
        <div className="relative">
          <Search className="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
          <input
            type="text"
            placeholder="Search"
            className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:text-white"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)} // Cập nhật giá trị tìm kiếm
          />
        </div>
      </div>

      {/* Tab Content */}
      {renderTabContent()}

      {/* Footer Section (Tab Switchers) */}
      <div className="flex justify-around p-4 border-t border-gray-300 dark:border-gray-700">
        {/* Archive Tab */}
        <div
          onClick={() => setActiveTab('archive')}
          className={cursor-pointer ${
            activeTab === 'archive' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <Archive className="w-6 h-6" />
        </div>
        {/* Friend Requests Tab */}
        <div
          onClick={() => setActiveTab('users')}
          className={relative cursor-pointer ${
            activeTab === 'users' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <Users className="w-6 h-6" />
          {friendRequests > 0 && (
            <div className="absolute top-0 right-0 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center">
              {friendRequests}
            </div>
          )}
        </div>
        {/* Messages Tab */}
        <div
          onClick={() => setActiveTab('messages')}
          className={cursor-pointer ${
            activeTab === 'messages' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <MessageCircle className="w-6 h-6" />
        </div>
      </div>
    </div>
  );
}

export default LeftSideBar;

ChatLayout.jsx
// ChatLayout.jsx
import React from 'react';
import LeftSideBar from './LeftSideBar';
import MainChat from './MainChat';
import RightSidebar from './RightSideBar';

function ChatLayout({
  selectedChat,
  setSelectedChat,
  chats,
  isDarkMode,
  toggleDarkMode,
  toggleMenuSidebar,
  setActiveTab,
  activeTab,
  friendRequests,
  renderTabContent,
  showRightSidebar,
  toggleRightSidebar,
  searchQuery, // Nhận searchQuery từ props
  setSearchQuery,
  sendFriendRequest,
}) {
  return (
    <>
      {/* Left Sidebar */}
      <LeftSideBar
          isDarkMode={isDarkMode}
          toggleDarkMode={toggleDarkMode}
          toggleMenuSidebar={toggleMenuSidebar}
          setActiveTab={setActiveTab}
          activeTab={activeTab}
          friendRequests={friendRequests}
          renderTabContent={renderTabContent}
          searchQuery={searchQuery} // Nhận searchQuery từ props// Nhận searchQuery từ props
          setSearchQuery={setSearchQuery} // Truyền setSearchQuery
          sendFriendRequest={sendFriendRequest}
        />

      {/* Main Chat Area */}
      <MainChat 
        selectedChat={selectedChat} 
        toggleRightSidebar={toggleRightSidebar} 
      />

      {/* Right Sidebar */}
      {showRightSidebar && (
        <RightSidebar
          selectedChat={selectedChat}
          
        />
      )}
    </>
  );
}

export default ChatLayout;


server
server.js
const express = require('express');
const http = require('http'); // Thay https bằng http
const { Server } = require('socket.io');
const userRoutes = require("./routes/auth");
const friendRoutes = require('./routes/friend');
const jwt = require('jsonwebtoken');
require('dotenv').config();  // Tải các biến môi trường từ file .env

// Tạo ứng dụng Express
const app = express();

const cors = require('cors');

// Enable CORS for all routes
app.use(cors());

// Middleware để xử lý JSON
app.use(express.json());

app.use('/api', userRoutes);

app.use('/friends', friendRoutes);

// Tạo server HTTP từ Express
const server = http.createServer(app); // Sử dụng http.createServer

// Tạo socket.io kết hợp với server HTTP
const io = new Server(server, {
  cors: {
    origin: '*', // Cho phép mọi nguồn kết nối (tuỳ chỉnh lại khi cần)
    methods: ['GET', 'POST'],
  },
});

// Middleware để xác thực token JWT cho Socket.io
// io.use((socket, next) => {
//   const token = socket.handshake.auth.token; // Lấy token từ phần auth của handshake

//   if (!token) {
//     return next(new Error('Authentication error: No token provided'));
//   }

//   try {
//     // Giải mã và xác thực token
//     const decoded = jwt.verify(token, process.env.JWT_SECRET); // Sử dụng JWT_SECRET từ file .env
//     socket.user = decoded; // Lưu thông tin người dùng vào socket để sử dụng sau này
//     next(); // Cho phép tiếp tục kết nối
//   } catch (error) {
//     return next(new Error('Authentication error: Invalid token'));
//   }
// });

// Định nghĩa một route đơn giản cho HTTP request
app.get('/', (req, res) => {
  res.send('Chào mừng bạn đến với server HTTP kết hợp socket.io!');
});

// Lắng nghe sự kiện kết nối từ client sử dụng socket.io
io.on('connection', (socket) => {
  console.log('Một client đã kết nối:', socket.id);

  // Xử lý sự kiện từ client (ví dụ gửi tin nhắn)
  socket.on('sendMessage', (message) => {
    console.log('Tin nhắn nhận được từ client:', message);
    io.emit('receiveMessage', message); // Phát tin nhắn cho tất cả client kết nối
  });
  // Lang nghe su kien offer tu mot client
  socket.on('offer',(offer,roomId)=>{
    console.log("Nhan duoc offer tu client:",socket.id);
    socket.broadcast.to(  roomId).emit('offer',offer);
  });
  socket.on('answer',(answer,roomId)=>{
    console.log("Nhan duoc answer tu client",socket.id);

    socket.broadcast.to(roomId).emit("answer",answer);
  });



  socket.on('ice-candidate',(candidate,roomId)=>{
    console.log("NHan duoc ICE candidate tu client:",socket.id);
    //Phat lai candidate den peer khac trong room
    socket.broadcast.to(roomId).emit('ice-candidate',candidate);
  });

  socket.on('join-room',(roomId)=>{
    socket.join(roomId);
    console.log(${socket.id} da tham gia phong ${roomId});
  })


  // Xử lý sự kiện ngắt kết nối từ client
  socket.on('disconnect', () => {
    console.log('Client đã ngắt kết nối:', socket.id);
  });
});

// Khởi động server tại cổng 3009
const PORT = 3009;
server.listen(PORT, () => {
  console.log(Server HTTP đang chạy tại http://172.20.10.4:${PORT});
});

Routes/auth.js
const express = require('express');
const bcrypt = require('bcrypt');
const db=require('../database/db');

const router = express.Router();
const userController=require('../controller/userController')

// Bộ nhớ tạm để lưu thông tin user (thay vì dùng database)
const users = [];

//Dang nhap
router.post('/login', userController.loginUser);


// Tạo người dùng mới
router.post('/users', userController.createUser);

// Lấy tất cả người dùng
router.get('/users', userController.getAllUsers);

// Lấy thông tin người dùng theo ID
router.get('/users/:id', userController.getUserById);

// Cập nhật thông tin người dùng theo ID
router.put('/users/:id', userController.updateUser);

// Xóa người dùng theo ID
router.delete('/users/:id', userController.deleteUser);



module.exports = router;

const express = require('express');
const chatController = require('../controller/chatController');

const router = express.Router();

// Tạo cuộc trò chuyện mới
router.post('/create', chatController.createChat);

// Gửi tin nhắn
router.post('/send', chatController.sendMessage);

// Lấy tất cả tin nhắn trong cuộc trò chuyện
router.get('/:chatId/messages', chatController.getMessages);

// Lấy tất cả cuộc trò chuyện của người dùng
router.get('/user/:userId', chatController.getUserChats);

module.exports = router;

Routes/friend.js
const express = require('express');
const router = express.Router();
const friendController = require('../controller/friendController');

// Gửi yêu cầu kết bạn
router.post('/request', friendController.sendFriendRequest);

// Chấp nhận yêu cầu kết bạn
router.post('/accept', friendController.acceptFriendRequest);

// Từ chối yêu cầu kết bạn
router.post('/decline', friendController.declineFriendRequest);

// Lấy danh sách bạn bè
router.get('/list', friendController.getFriendsList);

// Lấy danh sách yêu cầu kết bạn (cả gửi và nhận)
router.get('/requests', friendController.getFriendRequests);

module.exports = router;


const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User');

const Chat = sequelize.define('Chat', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: false, // Tên cuộc trò chuyện không được để trống
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: false, // ID của người tạo cuộc trò chuyện
    references: {
      model: 'Users',
      key: 'id'
    },
    onDelete: 'SET NULL', // Nếu người tạo bị xóa, trường này sẽ được đặt thành NULL
  },
  createdAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Chats', // Tên bảng trong cơ sở dữ liệu
  timestamps: true,
});

// Thiết lập mối quan hệ
Chat.belongsTo(User, { foreignKey: 'createdBy', as: 'creator' });

module.exports = Chat;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const ChatMember = sequelize.define('ChatMember', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Chats',
      key: 'id',
    },
    onDelete: 'CASCADE', // Xóa tất cả các thành viên khi cuộc trò chuyện bị xóa
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'CASCADE', // Xóa thành viên khi người dùng bị xóa
  },
  joinedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'ChatMembers',
  timestamps: true,
});

// Thiết lập mối quan hệ
ChatMember.belongsTo(Chat, { foreignKey: 'chatId' });
ChatMember.belongsTo(User, { foreignKey: 'userId' });

module.exports = ChatMember;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const Document = sequelize.define('Document', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Chats',
      key: 'id',
    },
    onDelete: 'CASCADE', // Xóa tài liệu khi cuộc trò chuyện bị xóa
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
  filePath: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  uploadedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Documents',
  timestamps: true,
});

// Thiết lập mối quan hệ
Document.belongsTo(Chat, { foreignKey: 'chatId' });
Document.belongsTo(User, { foreignKey: 'userId' });

module.exports = Document;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User'); // Import model User

const Friend = sequelize.define('Friend', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users',
      key: 'id',
    },
  },
  friend_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users',
      key: 'id',
    },
  },
  status: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'pending',
  },
  nick_name: {
    type: DataTypes.STRING,
    allowNull: true,
  },
  created_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  updated_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Friends',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
});

// Thiết lập mối quan hệ
// Thiết lập mối quan hệ
Friend.belongsTo(User, { foreignKey: 'user_id', as: 'userDetail' });
Friend.belongsTo(User, { foreignKey: 'friend_id', as: 'friendDetail' });


module.exports = Friend;
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const Message = sequelize.define('Message', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Chats', // Tên bảng cuộc trò chuyện
      key: 'id', // Khóa chính trong bảng chats
    },
    onDelete: 'CASCADE', // Xóa tất cả tin nhắn khi cuộc trò chuyện bị xóa
  },
  senderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users', // Tên bảng người dùng
      key: 'id', // Khóa chính trong bảng users
    },
    onDelete: 'SET NULL', // Đặt giá trị senderId thành NULL nếu người dùng bị xóa
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false, // Nội dung tin nhắn không được để trống
  },
  timestamp: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW, // Mặc định là thời điểm hiện tại
  },
}, {
  tableName: 'Messages', // Tên bảng trong cơ sở dữ liệu
  timestamps: true,
});

// Thiết lập mối quan hệ
Message.belongsTo(Chat, { foreignKey: 'chatId' });
Message.belongsTo(User, { foreignKey: 'senderId', as: 'sender' });

module.exports = Message;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User');

const Room = sequelize.define('Room', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  roomCode: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true, // Đảm bảo roomCode là duy nhất
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: true, // Tên phòng có thể để trống
  },
  createdAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  createdBy: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
}, {
  tableName: 'Rooms',
  timestamps: true,
});

// Thiết lập mối quan hệ
Room.belongsTo(User, { foreignKey: 'createdBy' });

module.exports = Room;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Room = require('./Room');
const User = require('./User');

const RoomMember = sequelize.define('RoomMember', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  roomId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Rooms',
      key: 'id',
    },
    onDelete: 'CASCADE', // Xóa tất cả thành viên khi phòng bị xóa
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'CASCADE', // Xóa thành viên khi người dùng bị xóa
  },
  joinedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'RoomMembers',
  timestamps: true,
});

// Thiết lập mối quan hệ
RoomMember.belongsTo(Room, { foreignKey: 'roomId' });
RoomMember.belongsTo(User, { foreignKey: 'userId' });

module.exports = RoomMember;
const {DataTypes} =require('sequelize');
const sequelize=require('../database/db')


// Dinh nghia model User anh xa voi bang User

const User=sequelize.define('User',{
    id:{
        type:DataTypes.INTEGER,
        primaryKey:true,
        autoIncrement:true
    },
    username:{
        type:DataTypes.STRING,
        allowNull:false,

    },
    email:{
        type:DataTypes.STRING,
        allowNull:false,
        unique:true,
        validate:{
            isEmail:true
        }

    },
    password:{
        type:'users',
        allowNull: false
    },
     
},
{
    tableName: 'Users',
    timestamps: true  
}
    
);
module.exports=User;
migration

'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      username: {
        type: Sequelize.STRING
      },
      email: {
        type: Sequelize.STRING
      },
      password: {
        type: Sequelize.STRING
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Users');
  }
};


'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Chats', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        type: Sequelize.STRING(100),
        allowNull: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      createdBy: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Chats');
  }
};

'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Messages', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      senderId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      timestamp: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Messages');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('ChatMembers', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      joinedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      unique: {
        type: Sequelize.STRING,
        unique: true,
        fields: ['chatId', 'userId']
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('ChatMembers');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Rooms', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      roomCode: {
        type: Sequelize.STRING(20),
        allowNull: false,
        unique: true
      },
      name: {
        type: Sequelize.STRING(100)
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      createdBy: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Rooms');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('RoomMembers', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      roomId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Rooms',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      joinedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      unique: {
        type: Sequelize.STRING,
        unique: true,
        fields: ['roomId', 'userId']
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('RoomMembers');
  }
};



'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Documents', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      },
      filePath: {
        type: Sequelize.STRING(255),
        allowNull: false
      },
      uploadedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Documents');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Friends', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Users', // Tên bảng mà bạn muốn liên kết
          key: 'id'  // Khóa chính của bảng Users
        },
        onDelete: 'CASCADE', // Nếu người dùng bị xóa, các bản ghi bạn bè sẽ bị xóa theo
      },
      friend_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Users', // Tên bảng mà bạn muốn liên kết
          key: 'id'  // Khóa chính của bảng Users
        },
        onDelete: 'CASCADE', // Nếu người bạn bị xóa, các bản ghi liên quan cũng sẽ bị xóa
      },
      status: {
        type: Sequelize.STRING,
        allowNull: false, // Bắt buộc
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP') // Mặc định là thời điểm hiện tại
      },
      nick_name: {
        type: Sequelize.STRING, // Tên hiển thị của người bạn
        allowNull: true, // Có thể để trống
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP') // Cập nhật thời gian
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Friends'); // Xóa bảng Friends nếu có
  }
};
const Chat = require('../models/Chat'); // Import model Chat
const Message = require('../models/Message'); // Import model Message
const User = require('../models/User'); // Import model User
const Friend = require('../models/Friend'); // Import model Friend
const ChatMember = require('../models/ChatMember'); // Import model ChatMember

const chatController = {
  // Tạo cuộc trò chuyện giữa 2 người dùng đã kết bạn
  createChat: async (req, res) => {
    try {
      const { userId1, userId2 } = req.body; // userId1 và userId2 là ID của 2 người dùng

      // Kiểm tra xem người dùng đã kết bạn chưa
      const friendRelation = await Friend.findOne({
        where: {
          user_id: userId1,
          friend_id: userId2,
          status: 'accepted'
        }
      });

      if (!friendRelation) {
        return res.status(400).json({ message: 'These users are not friends' });
      }

      // Tạo cuộc trò chuyện mới
      const chat = await Chat.create({
        name: `Chat between ${userId1} and ${userId2}`,
        createdBy: userId1 // Có thể lấy ID của người tạo cuộc trò chuyện
      });

      // Thêm các thành viên vào cuộc trò chuyện
      await ChatMember.create({ chatId: chat.id, userId: userId1 });
      await ChatMember.create({ chatId: chat.id, userId: userId2 });

      res.status(201).json({ message: 'Chat created successfully', chat });
    } catch (error) {
      console.error('Error creating chat:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // Gửi tin nhắn vào cuộc trò chuyện
  sendMessage: async (req, res) => {
    try {
      const { chatId, senderId, content } = req.body;

      // Kiểm tra xem người gửi có phải là thành viên của cuộc trò chuyện không
      const chatMember = await ChatMember.findOne({
        where: { chatId, userId: senderId }
      });

      if (!chatMember) {
        return res.status(403).json({ message: 'You are not a member of this chat' });
      }

      // Tạo tin nhắn mới
      const newMessage = await Message.create({
        chatId,
        senderId,
        content,
      });

      res.status(201).json({ message: 'Message sent successfully', message: newMessage });
    } catch (error) {
      console.error('Error sending message:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // Lấy tất cả tin nhắn trong cuộc trò chuyện
  getMessages: async (req, res) => {
    try {
      const { chatId } = req.params;

      // Lấy tất cả tin nhắn theo chatId
      const messages = await Message.findAll({
        where: { chatId },
        include: [{ model: User, as: 'sender', attributes: ['id', 'username'] }],
        order: [['timestamp', 'ASC']], // Sắp xếp theo thời gian
      });

      res.status(200).json(messages);
    } catch (error) {
      console.error('Error fetching messages:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // Lấy tất cả cuộc trò chuyện của người dùng
  getUserChats: async (req, res) => {
    try {
      const { userId } = req.params;

      const chats = await Chat.findAll({
        include: [
          {
            model: ChatMember,
            as: 'chatMembers',
            where: { userId }, // Sửa lại để chỉ định đúng userId
          },
        ],
      });

      res.status(200).json(chats);
    } catch (error) {
      console.error('Error fetching user chats:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },
};

module.exports = chatController;


controller/friendController.js
const Friend = require('../models/Friend');
const User = require('../models/User');

const friendController = {
  // Gửi yêu cầu kết bạn
  sendFriendRequest: async (req, res) => {
        try {
            const { userId, friendId } = req.body;
            console.log('Received userId:', userId);
            console.log('Received friendId:', friendId);

            // Kiểm tra nếu yêu cầu đã tồn tại
            const existingRequest = await Friend.findOne({
                where: { user_id: userId, friend_id: friendId }
            });

            if (existingRequest) {
                console.log('Friend request already exists');
                return res.status(400).json({ message: 'Friend request already exists' });
            }

            // Tạo yêu cầu kết bạn mới
            await Friend.create({ user_id: userId, friend_id: friendId, status: 'pending' });
            res.status(201).json({ message: 'Friend request sent' });
        } catch (error) {
            console.error('Error sending friend request:', error);
            res.status(500).json({ message: 'Internal server error' });
        }
    },


  // Chấp nhận yêu cầu kết bạn
  acceptFriendRequest: async (req, res) => {
    try {
      const { userId, friendId } = req.body;

      // Tìm yêu cầu kết bạn và cập nhật trạng thái thành 'accepted'
      const friendRequest = await Friend.findOne({
        where: { user_id: friendId, friend_id: userId, status: 'pending' }
      });

      if (!friendRequest) {
        return res.status(404).json({ message: 'Friend request not found' });
      }

      friendRequest.status = 'accepted';
      await friendRequest.save();

      // Tạo quan hệ bạn bè ngược lại (cả hai phía)
      await Friend.create({ user_id: userId, friend_id: friendId, status: 'accepted' });

      res.status(200).json({ message: 'Friend request accepted' });
    } catch (error) {
      console.error('Error accepting friend request:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // Từ chối yêu cầu kết bạn
  declineFriendRequest: async (req, res) => {
    try {
      const { userId, friendId } = req.body;

      // Tìm yêu cầu kết bạn và xóa nó
      const friendRequest = await Friend.findOne({
        where: { user_id: friendId, friend_id: userId, status: 'pending' }
      });

      if (!friendRequest) {
        return res.status(404).json({ message: 'Friend request not found' });
      }

      await friendRequest.destroy();
      res.status(200).json({ message: 'Friend request declined' });
    } catch (error) {
      console.error('Error declining friend request:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },


// Lấy danh sách bạn bè
getFriendsList: async (req, res) => {
  try {
    const { userId } = req.query;

    const friends = await Friend.findAll({
      where: { user_id: userId, status: 'accepted' },
      include: [
        { model: User, as: 'friendDetail', attributes: ['id', 'username', 'email'] }
      ]
    });

    res.status(200).json(friends);
  } catch (error) {
    console.error('Error fetching friends list:', error);
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
},



  

  // Lấy danh sách yêu cầu kết bạn
  getFriendRequests: async (req, res) => {
    try {
      const { userId } = req.query; // Lấy userId từ query params
  
      // Kiểm tra nếu userId tồn tại
      if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
      }
  
      const requests = await Friend.findAll({
        where: { friend_id: userId, status: 'pending' },
        include: [{ model: User, as: 'userDetail', attributes: ['id', 'username', 'email'] }],
      });
  
      res.status(200).json(requests);
    } catch (error) {
      console.error('Error fetching friend requests:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  }
  
};

module.exports = friendController;

userController.js
const bcrypt = require('bcrypt');
const User = require('../models/User');
const { json } = require('sequelize');
const jwt = require('jsonwebtoken');  // Sử dụng JWT để tạo token


const userController = {
    createUser: async (req, res) => {
        try {
            const { username, email, password } = req.body;

            // Kiểm tra email đã tồn tại hay chưa
            const existingUser = await User.findOne({ where: { email } });
            if (existingUser) {
                return res.status(400).json({ message: "Email is already registered" });
            }

            // Hash mật khẩu trước khi lưu
            const hashedPassword = await bcrypt.hash(password, 10);

            // Tạo người dùng mới
            const newUser = await User.create({
                username,
                email,
                password: hashedPassword // Sử dụng hashed password
            });

            res.status(201).json({
                message: "User created successfully",
                user: newUser
            });

        } catch (error) {
            console.error("Error creating user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    getAllUsers: async (req, res) => {
        try {
            const users = await User.findAll(); // Thêm await để chờ kết quả
            res.status(200).json(users);

        } catch (error) {
            console.error("Error fetching users:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    getUserById: async (req, res) => {
        try {
            const userId = req.params.id;
            const user = await User.findByPk(userId); // Thêm await

            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            res.status(200).json(user);
        } catch (error) {
            console.error("Error fetching user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    updateUser: async (req, res) => {
        try {
            const userId = req.params.id;
            const { username, email, password } = req.body;

            // Kiểm tra xem người dùng có tồn tại không
            const user = await User.findByPk(userId);
            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // Cập nhật thông tin người dùng
            user.username = username || user.username;
            user.email = email || user.email;

            if (password) {
                const hashedPassword = await bcrypt.hash(password, 10);
                user.password = hashedPassword; // Cập nhật password đã được hash
            }

            await user.save();

            res.status(200).json({
                message: "User updated successfully",
                user
            });

        } catch (error) {
            console.error("Error updating user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    deleteUser: async (req, res) => {
        try {
            const userId = req.params.id;

            // Kiểm tra người dùng có tồn tại hay không
            const user = await User.findByPk(userId);
            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // Xóa người dùng
            await user.destroy();

            res.status(200).json({ message: "User deleted successfully" });

        } catch (error) {
            console.error("Error deleting user", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },
    loginUser:async (req,res)=>{
        try {
            const {email,password}=req.body;

            const user=await User.findOne({where:{email}});
            if(!user){
                return res.status(400).json({message:"User not found"});
            }

            const validPassword=await bcrypt.compare(password,user.password);
            if(!validPassword){
                return res.status(400).json({message:"Invalid email or password"})

            }
            
            const token=jwt.sign(
                { id: user.id, email: user.email },
                process.env.JWT_SECRET,  // Khóa bí mật để mã hóa JWT (cần thiết lập trong .env)
                { expiresIn: '1h' } 
            )

            res.status(200).json({
                message:'Login successful',
                token,
                user:{
                    id:user.id,
                    username:user.username,
                    email:user.username
                }
            });
        } catch (error) {
            console.error('Error logging in:',error)
            res.status(500).json({message:"Internal server erorr"});
        }
    }
};

module.exports = userController;