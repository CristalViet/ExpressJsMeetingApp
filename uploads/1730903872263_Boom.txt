V·∫≠y d·ª±a v√†o code n√†y c·ªßa t√¥i, b·∫°n hi·ªÉu nh·ªØng g√¨
Client

App.jsx
import React, { useState, useEffect } from 'react';
import {
  Moon,
  Sun,
  Phone,
  Video,
  Info,
  Search,
  Archive,
  Users,
  MessageCircle,
  Send,
  Menu,
} from 'lucide-react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import NavBar from './NavigationBar';
import ChatLayout from './pages/Chat/ChatLayout';

import { HashRouter as Router, Routes, Route, Navigate } from 'react-router-dom'; // ƒê·∫£m b·∫£o c√≥ Navigate

import {user,messages} from './Mockdata';
import VideoCall from './pages/Call/VideoCall';
import MeetingRoom from './pages/Meeting/MeetingRoom';
import MeetingPage from './pages/Meeting/MeetingPage';
import ReactLogo from './assets/ok.jpg'; // ƒê·∫£m b·∫£o ƒë∆∞·ªùng d·∫´n ch√≠nh x√°c
import DocumentsPage from './pages/Documents/DocumentsPage';
import Auth from './pages/Login/Auth';
import io from 'socket.io-client'; // Import socket.io-client

const socketServerURL = 'http://172.20.10.4:3009'; // ƒê·ªãa ch·ªâ server Socket.io
export default function MessengerInterface() {
  const [chats, setChats] = useState([]);

  useEffect(() => {
    const fetchFriendRequests = async () => {
      try {
        const user = JSON.parse(localStorage.getItem('user'));
        const userId = user ? user.id : null;
  
        if (!userId) {
          throw new Error('User is not authenticated');
        }
  
        const response = await fetch(${socketServerURL}/friends/requests?userId=${userId}, {
          method: 'GET',
          headers: {
            Authorization: Bearer ${localStorage.getItem('token')},
          },
        });
  
        if (!response.ok) {
          throw new Error('Failed to fetch friend requests');
        }
  
        const requests = await response.json();
        setChats(requests.map(req => ({
          id: req.id,
          user_id: req.user_id,
          friend_id: req.friend_id,
          name: req.userDetail ? req.userDetail.username : 'Unknown', // L·∫•y th√¥ng tin t·ª´ userDetail
          status: req.status,
        })));
      } catch (error) {
        console.error('Error fetching friend requests:', error);
      }
    };
  
    fetchFriendRequests();
  }, []);
  

  
  

  const handleAccept = async (id) => {
    try {
      const chat = chats.find(chat => chat.id === id);
      
      if (!chat) {
        throw new Error('Friend request not found');
      }
  
      const user = JSON.parse(localStorage.getItem('user'));
      const userId = user ? user.id : null;
  
      if (!userId) {
        throw new Error('User is not authenticated');
      }
  
      console.log("User ID:", userId);
      console.log("Friend ID:", chat.friend_id); // S·ª≠ d·ª•ng friend_id thay v√¨ user_id
  
      const response = await fetch(${socketServerURL}/friends/accept, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: Bearer ${localStorage.getItem('token')},
        },
        body: JSON.stringify({
          userId: userId,          // ID c·ªßa ng∆∞·ªùi ch·∫•p nh·∫≠n y√™u c·∫ßu (ng∆∞·ªùi ƒëƒÉng nh·∫≠p)
          friendId: chat.user_id   // ID c·ªßa ng∆∞·ªùi g·ª≠i y√™u c·∫ßu (b·∫°n b√®)
        }),
      });
  
      if (!response.ok) {
        const errorResponse = await response.json();
        throw new Error(Failed to accept friend request: ${errorResponse.message});
      }
  
      const result = await response.json();
      console.log(result.message);
  
      setChats(prevChats => prevChats.filter(chat => chat.id !== id));
    } catch (error) {
      console.error('Error accepting friend request:', error);
    }
  };
  
  
  
  

  const handleDecline = async (id) => {
    try {
      const chat = chats.find(chat => chat.id === id);
      
      if (!chat) {
        throw new Error('Friend request not found');
      }
  
      const user = JSON.parse(localStorage.getItem('user'));
      const userId = user ? user.id : null;
  
      if (!userId) {
        throw new Error('User is not authenticated');
      }
  
      const response = await fetch(${socketServerURL}/friends/decline, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: Bearer ${localStorage.getItem('token')},
        },
        body: JSON.stringify({
          userId: userId,           // ID c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i (ng∆∞·ªùi nh·∫≠n y√™u c·∫ßu)
          friendId: chat.user_id    // ID c·ªßa ng∆∞·ªùi g·ª≠i y√™u c·∫ßu k·∫øt b·∫°n
        }),
      });
  
      if (!response.ok) {
        throw new Error('Failed to decline friend request');
      }
  
      setChats(prevChats => prevChats.filter(chat => chat.id !== id));
    } catch (error) {
      console.error('Error declining friend request:', error);
    }
  };
  

  
  const [selectedChat, setSelectedChat] = useState(chats[0]);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [showRightSidebar, setShowRightSidebar] = useState(false);
  const [showMenuSidebar, setShowMenuSidebar] = useState(false);
  const [activeTab, setActiveTab] = useState('messages'); // Default tab is 'messages'
  const [isAuthenticated, setIsAuthenticated] = useState(!!localStorage.getItem('token'));
  const [socket, setSocket] = useState(null); // State ƒë·ªÉ l∆∞u socket instance
  const user = JSON.parse(localStorage.getItem('user')); // L·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ local storage
  const userName = user ? user.username : "Guest"; // L·∫•y t√™n ng∆∞·ªùi d√πng ho·∫∑c hi·ªÉn th·ªã "Guest"
  const userId = user ? user.id : null; // L·∫•y ID ng∆∞·ªùi d√πng
  const handleLogin = (token) => {
    localStorage.setItem('token', token); // L∆∞u token v√†o Local Storage
    setIsAuthenticated(true); // C·∫≠p nh·∫≠t tr·∫°ng th√°i x√°c th·ª±c
    const socketConnection = io(socketServerURL, {
      auth: { token }, // G·ª≠i token khi k·∫øt n·ªëi
    });

    socketConnection.on('connect', () => {
      console.log('Connected to socket server');
    });

    socketConnection.on('disconnect', () => {
      console.log('Disconnected from socket server');
    });

    setSocket(socketConnection); // L∆∞u socket instance
  };
  //
  useEffect(() => {
    // ƒê·∫øm s·ªë ph·∫ßn t·ª≠ c√≥ status l√† 'accepted' v√† c·∫≠p nh·∫≠t friendRequests
    const countStatusZero = chats.filter((chat) => chat.status === 'accepted').length;
    setFriendRequests(countStatusZero);
  }, [chats]);

  const [friendRequests, setFriendRequests] = useState(); // Number of friend requests

  const [friends, setFriends] = useState([]);

// useEffect ƒë·ªÉ l·∫•y danh s√°ch b·∫°n b√® sau khi component mount
useEffect(() => {
  const fetchFriendsList = async () => {
    try {
      const response = await fetch(${socketServerURL}/friends/list?userId=${userId}, {
        method: 'GET',
        headers: {
          Authorization: Bearer ${localStorage.getItem('token')},
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch friends list');
      }

      const friendsList = await response.json();
      setFriends(friendsList.map(friend => ({
        id: friend.id,
        name: friend.friendDetail.username, // D√πng alias friendDetail t·ª´ API
        email: friend.friendDetail.email,
      })));
    } catch (error) {
      console.error('Error fetching friends list:', error);
    }
  };

  if (userId) {
    fetchFriendsList();
  }
}, [userId]);

//ƒë·ªïi m√†u
  useEffect(() => {
    if (isDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [isDarkMode]);
//set ƒë·ªÉ n√∫t ƒë·ªïi m√†u
  const toggleDarkMode = () => {
    setIsDarkMode(!isDarkMode);
  };
// b·∫≠t t·∫Øt navbar
  const toggleRightSidebar = () => {
    setShowRightSidebar(!showRightSidebar);
  };
  
  
  const toggleMenuSidebar = () => {
    setShowMenuSidebar(!showMenuSidebar);
  };
  const [allUsers, setAllUsers] = useState([]); // State ƒë·ªÉ l∆∞u danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng

//l·∫•y t·∫•t c·∫£ users
useEffect(() => {
  const fetchUsers = async () => {
    try {
      const response = await fetch(${socketServerURL}/api/users, {
        headers: {
          Authorization: Bearer ${localStorage.getItem('token')}
        }
      });

      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }

      const users = await response.json();
      setAllUsers(users);
    } catch (error) {
      console.error('Error fetching users:', error);
    }
  };

  if (activeTab === 'archive') {
    fetchUsers();
  }
}, [activeTab]);
//render ph·∫ßn search
const [searchQuery, setSearchQuery] = useState('');

//G·ª¨i LMKB
const sendFriendRequest = async (friendId) => {
  try {
    // L·∫•y ID ng∆∞·ªùi d√πng t·ª´ localStorage
    const user = JSON.parse(localStorage.getItem('user')); 
    const userId = user ? user.id : null; // L·∫•y ID ng∆∞·ªùi d√πng t·ª´ localStorage

    const response = await fetch(${socketServerURL}/friends/request, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: Bearer ${localStorage.getItem('token')},
      },
      body: JSON.stringify({ userId: userId, friendId: friendId }), // userId l√† ID c·ªßa ng∆∞·ªùi g·ª≠i y√™u c·∫ßu, friendId l√† ID c·ªßa b·∫°n
    });

    if (!response.ok) {
      throw new Error('Failed to send friend request');
    }

    const result = await response.json();
    console.log('Friend request sent:', result);
  } catch (error) {
    console.error('Error sending friend request:', error);
  }
};


const renderTabContent = () => {
  switch (activeTab) {
    case 'archive':
      const filteredUsers = allUsers.filter(user =>
        user.username.toLowerCase().includes(searchQuery.toLowerCase())
      );
      return (
        <div className="overflow-y-auto flex-1 p-4">
          <h2 className="text-2xl font-semibold text-center dark:text-white mb-6">
            All Users
          </h2>

          {filteredUsers.map((user) => (
            <div key={user.id} className="flex flex-col sm:flex-row items-center sm:items-start p-6 bg-white dark:bg-gray-800 rounded-xl mb-5 shadow-lg transition-all hover:bg-gray-50 dark:hover:bg-gray-700 space-y-4 sm:space-y-0 sm:space-x-6">
              {/* N·ªôi dung hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi d√πng */}
              <Avatar className="w-20 h-20 rounded-full shadow-md flex-shrink-0">
                <AvatarImage src={ReactLogo} alt={user.username} />
                <AvatarFallback>{user.username.charAt(0)}</AvatarFallback>
              </Avatar>
              <div className="flex-1 text-center sm:text-left">
                <span className="text-xl font-medium dark:text-white block mb-2">
                  {user.username}
                </span>
                <button className="bg-green-500 text-white px-6 py-2 rounded-lg hover:bg-green-600 transition-all text-sm w-full sm:w-auto" onClick={() => sendFriendRequest(user.id)}>
                  Add Friend
                </button>
              </div>
            </div>
          ))}
        </div>
      );

      case 'users':
        return (
          <div className="overflow-y-auto flex-1 p-4">
            <h2 className="text-2xl font-semibold text-center dark:text-white mb-6">
              Friend Requests
            </h2>

            {/* Ki·ªÉm tra n·∫øu kh√¥ng c√≥ y√™u c·∫ßu k·∫øt b·∫°n */}
            {chats.length === 0 ? (
              <p className="text-center text-gray-500 dark:text-gray-400">
                No friend requests available.
              </p>
            ) : (
              chats.map((chat) => (
                <div
                  key={chat.id}
                  className="flex flex-col sm:flex-row items-center sm:items-start p-6 bg-white dark:bg-gray-800 rounded-xl mb-5 shadow-lg transition-all hover:bg-gray-50 dark:hover:bg-gray-700 space-y-4 sm:space-y-0 sm:space-x-6"
                >
                  <Avatar className="w-20 h-20 rounded-full shadow-md flex-shrink-0">
                    <AvatarImage src={ReactLogo} alt={chat.name} />
                    <AvatarFallback>{chat.name ? chat.name.charAt(0) : '?'}</AvatarFallback>
                  </Avatar>
                  <div className="flex-1 text-center sm:text-left">
                    <span className="text-xl font-medium dark:text-white block mb-2">
                      {chat.name}
                    </span>
                    <div className="flex flex-col sm:flex-row sm:space-x-4 space-y-3 sm:space-y-0 mt-2">
                      {/* Button Accept */}
                      <button
                        className="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 transition-all text-sm w-full sm:w-auto"
                        onClick={() => handleAccept(chat.id)}
                      >
                        Accept
                      </button>

                      {/* Button Decline */}
                      <button
                        className="bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-white px-6 py-2 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 transition-all text-sm w-full sm:w-auto"
                        onClick={() => handleDecline(chat.id)}
                      >
                        Decline
                      </button>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        );


        case 'messages':
      default:
        // Hi·ªÉn th·ªã danh s√°ch b·∫°n b√®
        const filteredFriends = friends.filter(friend =>
          friend.name.toLowerCase().includes(searchQuery.toLowerCase())
        );
        return (
          <div className="overflow-y-auto flex-1">
            {filteredFriends.map((friend) => (
              <div
                key={friend.id}
                className={flex items-center p-4 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-800 cursor-pointer transition-all ${
                  selectedChat && selectedChat.id === friend.id ? 'bg-blue-100 dark:bg-blue-900' : ''
                }}
                onClick={() => setSelectedChat(friend)}
              >
                <Avatar className="w-12 h-12 mr-4 shadow-md dark:shadow-gray-700">
                  <AvatarImage src={ReactLogo} alt={friend.name} />
                  <AvatarFallback>{friend.name.charAt(0)}</AvatarFallback>
                </Avatar>
                <div className="flex-1">
                  <div className="flex justify-between items-center">
                    <h2 className="font-semibold dark:text-white">{friend.name}</h2>
                    <span className="text-sm text-gray-500 dark:text-gray-400">{friend.email}</span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        );
          
    }
};

  return (
    <Router>
      <div className="flex h-screen bg-white dark:bg-gray-900 transition-colors  duration-200">
          {/* Menu Sidebar */}
          <div
            className={fixed top-0 left-0 h-full w-64 z-50 bg-gray-100 dark:bg-gray-800 shadow-lg border-r border-gray-300 dark:border-gray-700 transition-transform transform ${
              showMenuSidebar ? 'translate-x-0' : '-translate-x-full'
            }}
          >
            <NavBar toggleMenuSidebar={toggleMenuSidebar} />
          </div>
          {showMenuSidebar && (
          <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-40"
          onClick={toggleMenuSidebar}
        ></div>
          )}
        {/*RouterPage*/}

          

          <Routes>
            <Route path='/' element={<Auth onLogin={handleLogin} />} />
            <Route
              path="/chat"
              element={isAuthenticated ? (
                <ChatLayout
                selectedChat={selectedChat}
                setSelectedChat={setSelectedChat}
                chats={chats}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}
                toggleMenuSidebar={toggleMenuSidebar}
                setActiveTab={setActiveTab}
                activeTab={activeTab}
                friendRequests={friendRequests}
                renderTabContent={renderTabContent}
                showRightSidebar={showRightSidebar}
                toggleRightSidebar={toggleRightSidebar}
                searchQuery={searchQuery} // Truy·ªÅn searchQuery v√†o ChatLayout
                setSearchQuery={setSearchQuery} // Truy·ªÅn setSearchQuery v√†o ChatLayout
                />
              ) : (
                <Navigate to="/" replace /> // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p
              )}
            />
            <Route path="/meeting" element={ isAuthenticated ? (
              <MeetingPage 
                toggleMenuSidebar={toggleMenuSidebar}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}
                userName = {userName}
              />
              
            ) : (
              <Navigate to="/" replace /> // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p
            )} />
            <Route path="/meeting/:roomId" element={isAuthenticated ? (
                <VideoCall />
              ) : (
                <Navigate to="/" replace />
              )} />
            <Route path="/document" element={ isAuthenticated ? (
              <DocumentsPage
                toggleMenuSidebar={toggleMenuSidebar}
                isDarkMode={isDarkMode}
                toggleDarkMode={toggleDarkMode}

                setSelectedChat={setSelectedChat}
              />
            ) : (
              <Navigate to="/" replace /> // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p
            )}>

            </Route>

          </Routes>
      </div>
    </Router>
  );
}

Auth.jsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom'; // Import useNavigate

function AuthPage({ onLogin }) {
  const [isLogin, setIsLogin] = useState(true); // Qu·∫£n l√Ω tr·∫°ng th√°i ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
  const toggleAuthMode = () => setIsLogin(!isLogin); // Chuy·ªÉn ƒë·ªïi gi·ªØa ƒëƒÉng nh·∫≠p v√† ƒëƒÉng k√Ω

  return (
    <div className="w-full p-6 space-y-6 bg-white dark:bg-gray-800 shadow-md rounded-lg" style={{ margin: 'auto', width: '400px' }}>
      <h2 className="text-center text-2xl font-bold text-gray-800 dark:text-white">
        {isLogin ? 'Login' : 'Register'}
      </h2>

      {isLogin ? <LoginForm onLogin={onLogin} /> : <RegisterForm />}

      <p className="text-center text-sm text-gray-600 dark:text-gray-400">
        {isLogin ? "Don't have an account?" : 'Already have an account?'}{' '}
        <button onClick={toggleAuthMode} className="font-medium text-blue-500 hover:underline">
          {isLogin ? 'Register' : 'Login'}
        </button>
      </p>
    </div>
  );
}

function LoginForm({ onLogin }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const navigate = useNavigate(); // Kh·ªüi t·∫°o useNavigate
  const socketServerURL ='http://172.20.10.4:3009'
  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch(${socketServerURL}/api/login, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error('Login failed!');
      }

      const data = await response.json();
      console.log('Login successful:', data);

      // L∆∞u token v√† th√¥ng tin ng∆∞·ªùi d√πng v√†o local storage
      localStorage.setItem('token', data.token);
      localStorage.setItem('user', JSON.stringify(data.user)); // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng

      // G·ªçi h√†m onLogin ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i x√°c th·ª±c trong App
      onLogin(data.token);

      // ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn main page sau khi ƒëƒÉng nh·∫≠p
      navigate(/chat?token=${data.token}); // Th√™m token v√†o URL
    } catch (error) {
      console.error('Error during login:', error);
      setMessage('Login failed. Please check your email and password.');
    }
  };

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      {message && <p className="text-red-500 text-sm">{message}</p>}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Email</label>
        <input
          type="email"
          required
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Password</label>
        <input
          type="password"
          required
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <button
        type="submit"
        className="w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600"
      >
        Login
      </button>
    </form>
  );
}

function RegisterForm() {
  const [username, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const navigate = useNavigate(); // Kh·ªüi t·∫°o useNavigate

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch(${socketServerURL}/api/users, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, email, password }),
      });

      if (!response.ok) {
        throw new Error('Registration failed!');
      }

      const data = await response.json();
      console.log('Registration successful:', data);
      setMessage('Registration successful! Redirecting to login...');

      // Chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p sau khi ƒëƒÉng k√Ω th√†nh c√¥ng
      setTimeout(() => {
        navigate('/');
      }, 2000);
    } catch (error) {
      console.error('Error during registration:', error);
      setMessage('Registration failed. Please try again.');
    }
  };

  return (
    <form className="space-y-4" onSubmit={handleSubmit}>
      {message && <p className="text-red-500 text-sm">{message}</p>}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Name</label>
        <input
          type="text"
          required
          value={username}
          onChange={(e) => setName(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Email</label>
        <input
          type="email"
          required
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Password</label>
        <input
          type="password"
          required
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full px-4 py-2 mt-1 border rounded-lg focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
        />
      </div>
      <button
        type="submit"
        className="w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600"
      >
        Register
      </button>
    </form>
  );
}

export default AuthPage;

RightSideBar.jsx
import React from 'react';
import {
  Avatar,
  AvatarFallback,
  AvatarImage
} from '@/components/ui/avatar';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger
} from '@/components/ui/tabs';

function RightSidebar({ selectedChat}) {
  return (
    <div className="w-64 border-l border-gray-200 dark:border-gray-700 p-4 transition-transform transform">
      <Tabs defaultValue="info">
        <TabsList className="grid dark:text-white w-full grid-cols-2">
          <TabsTrigger value="info">Info</TabsTrigger>
          <TabsTrigger value="files">Files</TabsTrigger>
        </TabsList>

        {/* Tab Content for Info */}
        <TabsContent value="info" className="mt-4">
          <div className="text-center">
            <Avatar className="w-20 h-20 dark:text-white mx-auto shadow-md dark:shadow-gray-700">
              <AvatarImage src={/placeholder.svg?height=80&width=80} alt={selectedChat?.name} />
              <AvatarFallback>{selectedChat?.name.charAt(0)}</AvatarFallback>
            </Avatar>
            <h3 className="mt-2 font-semibold dark:text-white">{selectedChat?.name}</h3>
            <p className="text-sm text-gray-500 dark:text-gray-400">Active 2h ago</p>

            {/* Button to create group */}
            <button
              onClick={() => handleCreateGroup(selectedChat?.name)}
              className="mt-4 px-4 py-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 dark:text-black dark:bg-white dark:hover:bg-blue-500"
            >
              Create Group with {selectedChat?.name}
            </button>
          </div>
        </TabsContent>

        {/* Tab Content for Files */}
        <TabsContent value="files" className="mt-4">
          <p className="text-center text-gray-500 dark:text-gray-400">No files shared yet</p>
        </TabsContent>
      </Tabs>
    </div>
  );
}

export default RightSidebar;


MainChat.jsx
import React from 'react';
import { Phone, Video, Info, Send } from 'lucide-react';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';

function MainChat({ selectedChat, toggleRightSidebar }) {
  // D·ªØ li·ªáu gi·∫£ c·ªßa tin nh·∫Øn
  const messages = [
    { sender: 'A', message: 'Hello, how are you?', timestamp: '10:00 AM' },
    { sender: 'B', message: 'I am fine, thank you! And you?', timestamp: '10:02 AM' },
    { sender: 'A', message: 'Doing well, thanks for asking!', timestamp: '10:03 AM' },
  ];

  return (
    <div className="flex-1 flex flex-col">
      {selectedChat && (
        <>
          {/* Header Section */}
          <div className="p-4 flex justify-between items-center border-b border-gray-300 dark:border-gray-700">
            <div className="flex items-center">
              <Avatar className="w-10 h-10 mr-3 dark:shadow-gray-700 dark:text-white shadow-md">
                <AvatarImage src={/placeholder.svg?height=40&width=40} alt={selectedChat.name} />
                <AvatarFallback>{selectedChat.name.charAt(0)}</AvatarFallback>
              </Avatar>
              <div>
                <h2 className="font-semibold dark:text-white">{selectedChat.name}</h2>
                <p className="text-sm text-gray-600 dark:text-gray-400">Online</p>
              </div>
            </div>
            <div className="flex space-x-4">
              <Phone className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors" />
              <Video className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors" />
              <Info
                className="w-6 h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-gray-800 dark:hover:text-gray-300 transition-colors"
                onClick={toggleRightSidebar}
              />
            </div>
          </div>

          {/* Chat Messages Section */}
          <div className="flex-1 p-4 space-y-4">
            {messages.map((msg, index) => (
              <div
                key={index}
                className={flex ${msg.sender === 'A' ? 'justify-start' : 'justify-end'}}
              >
                <div className={p-3 rounded-lg ${msg.sender === 'A' ? 'bg-gray-200' : 'bg-blue-500 text-white'}}>
                  <p className="text-sm">{msg.message}</p>
                  <p className="text-xs text-gray-500">{msg.timestamp}</p>
                </div>
              </div>
            ))}
          </div>

          {/* Input Section */}
          <div className="p-4 border-t border-gray-300 dark:border-gray-700">
            <div className="flex items-center">
              <input
                type="file"
                id="file-upload"
                className="hidden"
                onChange={(e) => handleFileUpload(e)}
              />
              <label
                htmlFor="file-upload"
                className="m-2 p-2 bg-gray-300 dark:bg-white text-white dark:text-black rounded-full shadow-md hover:opacity-90 transition-opacity cursor-pointer"
              >
                <span className="w-5 h-5">üìé</span>
              </label>
              <input
                type="text"
                placeholder="Type a message..."
                className="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:text-white"
              />
              <button className="ml-2 p-2 bg-blue-500 dark:bg-white text-white dark:text-black rounded-full shadow-md hover:opacity-90 transition-opacity">
                <Send className="w-5 h-5" />
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}

export default MainChat;

LeftSideBar.jsx
import React from 'react';
import {
  Menu,
  Sun,
  Moon,
  Search,
  Archive,
  Users,
  MessageCircle,
} from 'lucide-react';

function LeftSideBar({ 
  isDarkMode, 
  toggleDarkMode, 
  toggleMenuSidebar, 
  setActiveTab, 
  activeTab, 
  friendRequests, 
  renderTabContent,
  title='Chats' ,
  searchQuery,
  setSearchQuery,
  sendFriendRequest
}) {
  return (
    <div className="w-1/3 border-r border-gray-300 dark:border-gray-700 flex flex-col">
      {/* Header Section */}
      <div className="p-4 flex justify-between items-center border-b border-gray-300 dark:border-gray-700 shadow-md dark:shadow-gray-700">
        <div className="flex items-center space-x-3">
          <Menu
            className="w-5 h-5 sm:w-6 sm:h-6 text-gray-600 dark:text-gray-400 cursor-pointer hover:text-blue-500 dark:hover:text-blue-400 transition-all duration-200"
            onClick={toggleMenuSidebar}
          />
          <h1 className="text-base sm:text-lg md:text-2xl font-bold text-gray-800 dark:text-gray-200 ">{title}</h1>
        </div>
        <div className="flex items-center space-x-2">
          <button
            className="flex items-center justify-center p-1 rounded-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-all duration-200"
            onClick={toggleDarkMode}
          >
            {isDarkMode ? (
              <Sun className="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-yellow-500" />
            ) : (
              <Moon className="w-4 h-4 sm:w-5 sm:h-5 md:w-6 md:h-6 text-gray-600 dark:text-gray-400" />
            )}
          </button>
        </div>
      </div>

      {/* Search Section */}
      <div className="p-4 border-b border-gray-300 dark:border-gray-700">
        <div className="relative">
          <Search className="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
          <input
            type="text"
            placeholder="Search"
            className="w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-800 dark:text-white"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)} // C·∫≠p nh·∫≠t gi√° tr·ªã t√¨m ki·∫øm
          />
        </div>
      </div>

      {/* Tab Content */}
      {renderTabContent()}

      {/* Footer Section (Tab Switchers) */}
      <div className="flex justify-around p-4 border-t border-gray-300 dark:border-gray-700">
        {/* Archive Tab */}
        <div
          onClick={() => setActiveTab('archive')}
          className={cursor-pointer ${
            activeTab === 'archive' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <Archive className="w-6 h-6" />
        </div>
        {/* Friend Requests Tab */}
        <div
          onClick={() => setActiveTab('users')}
          className={relative cursor-pointer ${
            activeTab === 'users' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <Users className="w-6 h-6" />
          {friendRequests > 0 && (
            <div className="absolute top-0 right-0 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center">
              {friendRequests}
            </div>
          )}
        </div>
        {/* Messages Tab */}
        <div
          onClick={() => setActiveTab('messages')}
          className={cursor-pointer ${
            activeTab === 'messages' ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400'
          } hover:text-blue-600 dark:hover:text-gray-300 transition-colors}
        >
          <MessageCircle className="w-6 h-6" />
        </div>
      </div>
    </div>
  );
}

export default LeftSideBar;

ChatLayout.jsx
// ChatLayout.jsx
import React from 'react';
import LeftSideBar from './LeftSideBar';
import MainChat from './MainChat';
import RightSidebar from './RightSideBar';

function ChatLayout({
  selectedChat,
  setSelectedChat,
  chats,
  isDarkMode,
  toggleDarkMode,
  toggleMenuSidebar,
  setActiveTab,
  activeTab,
  friendRequests,
  renderTabContent,
  showRightSidebar,
  toggleRightSidebar,
  searchQuery, // Nh·∫≠n searchQuery t·ª´ props
  setSearchQuery,
  sendFriendRequest,
}) {
  return (
    <>
      {/* Left Sidebar */}
      <LeftSideBar
          isDarkMode={isDarkMode}
          toggleDarkMode={toggleDarkMode}
          toggleMenuSidebar={toggleMenuSidebar}
          setActiveTab={setActiveTab}
          activeTab={activeTab}
          friendRequests={friendRequests}
          renderTabContent={renderTabContent}
          searchQuery={searchQuery} // Nh·∫≠n searchQuery t·ª´ props// Nh·∫≠n searchQuery t·ª´ props
          setSearchQuery={setSearchQuery} // Truy·ªÅn setSearchQuery
          sendFriendRequest={sendFriendRequest}
        />

      {/* Main Chat Area */}
      <MainChat 
        selectedChat={selectedChat} 
        toggleRightSidebar={toggleRightSidebar} 
      />

      {/* Right Sidebar */}
      {showRightSidebar && (
        <RightSidebar
          selectedChat={selectedChat}
          
        />
      )}
    </>
  );
}

export default ChatLayout;


server
server.js
const express = require('express');
const http = require('http'); // Thay https b·∫±ng http
const { Server } = require('socket.io');
const userRoutes = require("./routes/auth");
const friendRoutes = require('./routes/friend');
const jwt = require('jsonwebtoken');
require('dotenv').config();  // T·∫£i c√°c bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env

// T·∫°o ·ª©ng d·ª•ng Express
const app = express();

const cors = require('cors');

// Enable CORS for all routes
app.use(cors());

// Middleware ƒë·ªÉ x·ª≠ l√Ω JSON
app.use(express.json());

app.use('/api', userRoutes);

app.use('/friends', friendRoutes);

// T·∫°o server HTTP t·ª´ Express
const server = http.createServer(app); // S·ª≠ d·ª•ng http.createServer

// T·∫°o socket.io k·∫øt h·ª£p v·ªõi server HTTP
const io = new Server(server, {
  cors: {
    origin: '*', // Cho ph√©p m·ªçi ngu·ªìn k·∫øt n·ªëi (tu·ª≥ ch·ªânh l·∫°i khi c·∫ßn)
    methods: ['GET', 'POST'],
  },
});

// Middleware ƒë·ªÉ x√°c th·ª±c token JWT cho Socket.io
// io.use((socket, next) => {
//   const token = socket.handshake.auth.token; // L·∫•y token t·ª´ ph·∫ßn auth c·ªßa handshake

//   if (!token) {
//     return next(new Error('Authentication error: No token provided'));
//   }

//   try {
//     // Gi·∫£i m√£ v√† x√°c th·ª±c token
//     const decoded = jwt.verify(token, process.env.JWT_SECRET); // S·ª≠ d·ª•ng JWT_SECRET t·ª´ file .env
//     socket.user = decoded; // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√†o socket ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
//     next(); // Cho ph√©p ti·∫øp t·ª•c k·∫øt n·ªëi
//   } catch (error) {
//     return next(new Error('Authentication error: Invalid token'));
//   }
// });

// ƒê·ªãnh nghƒ©a m·ªôt route ƒë∆°n gi·∫£n cho HTTP request
app.get('/', (req, res) => {
  res.send('Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi server HTTP k·∫øt h·ª£p socket.io!');
});

// L·∫Øng nghe s·ª± ki·ªán k·∫øt n·ªëi t·ª´ client s·ª≠ d·ª•ng socket.io
io.on('connection', (socket) => {
  console.log('M·ªôt client ƒë√£ k·∫øt n·ªëi:', socket.id);

  // X·ª≠ l√Ω s·ª± ki·ªán t·ª´ client (v√≠ d·ª• g·ª≠i tin nh·∫Øn)
  socket.on('sendMessage', (message) => {
    console.log('Tin nh·∫Øn nh·∫≠n ƒë∆∞·ª£c t·ª´ client:', message);
    io.emit('receiveMessage', message); // Ph√°t tin nh·∫Øn cho t·∫•t c·∫£ client k·∫øt n·ªëi
  });
  // Lang nghe su kien offer tu mot client
  socket.on('offer',(offer,roomId)=>{
    console.log("Nhan duoc offer tu client:",socket.id);
    socket.broadcast.to(  roomId).emit('offer',offer);
  });
  socket.on('answer',(answer,roomId)=>{
    console.log("Nhan duoc answer tu client",socket.id);

    socket.broadcast.to(roomId).emit("answer",answer);
  });



  socket.on('ice-candidate',(candidate,roomId)=>{
    console.log("NHan duoc ICE candidate tu client:",socket.id);
    //Phat lai candidate den peer khac trong room
    socket.broadcast.to(roomId).emit('ice-candidate',candidate);
  });

  socket.on('join-room',(roomId)=>{
    socket.join(roomId);
    console.log(${socket.id} da tham gia phong ${roomId});
  })


  // X·ª≠ l√Ω s·ª± ki·ªán ng·∫Øt k·∫øt n·ªëi t·ª´ client
  socket.on('disconnect', () => {
    console.log('Client ƒë√£ ng·∫Øt k·∫øt n·ªëi:', socket.id);
  });
});

// Kh·ªüi ƒë·ªông server t·∫°i c·ªïng 3009
const PORT = 3009;
server.listen(PORT, () => {
  console.log(Server HTTP ƒëang ch·∫°y t·∫°i http://172.20.10.4:${PORT});
});

Routes/auth.js
const express = require('express');
const bcrypt = require('bcrypt');
const db=require('../database/db');

const router = express.Router();
const userController=require('../controller/userController')

// B·ªô nh·ªõ t·∫°m ƒë·ªÉ l∆∞u th√¥ng tin user (thay v√¨ d√πng database)
const users = [];

//Dang nhap
router.post('/login', userController.loginUser);


// T·∫°o ng∆∞·ªùi d√πng m·ªõi
router.post('/users', userController.createUser);

// L·∫•y t·∫•t c·∫£ ng∆∞·ªùi d√πng
router.get('/users', userController.getAllUsers);

// L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
router.get('/users/:id', userController.getUserById);

// C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng theo ID
router.put('/users/:id', userController.updateUser);

// X√≥a ng∆∞·ªùi d√πng theo ID
router.delete('/users/:id', userController.deleteUser);



module.exports = router;

const express = require('express');
const chatController = require('../controller/chatController');

const router = express.Router();

// T·∫°o cu·ªôc tr√≤ chuy·ªán m·ªõi
router.post('/create', chatController.createChat);

// G·ª≠i tin nh·∫Øn
router.post('/send', chatController.sendMessage);

// L·∫•y t·∫•t c·∫£ tin nh·∫Øn trong cu·ªôc tr√≤ chuy·ªán
router.get('/:chatId/messages', chatController.getMessages);

// L·∫•y t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán c·ªßa ng∆∞·ªùi d√πng
router.get('/user/:userId', chatController.getUserChats);

module.exports = router;

Routes/friend.js
const express = require('express');
const router = express.Router();
const friendController = require('../controller/friendController');

// G·ª≠i y√™u c·∫ßu k·∫øt b·∫°n
router.post('/request', friendController.sendFriendRequest);

// Ch·∫•p nh·∫≠n y√™u c·∫ßu k·∫øt b·∫°n
router.post('/accept', friendController.acceptFriendRequest);

// T·ª´ ch·ªëi y√™u c·∫ßu k·∫øt b·∫°n
router.post('/decline', friendController.declineFriendRequest);

// L·∫•y danh s√°ch b·∫°n b√®
router.get('/list', friendController.getFriendsList);

// L·∫•y danh s√°ch y√™u c·∫ßu k·∫øt b·∫°n (c·∫£ g·ª≠i v√† nh·∫≠n)
router.get('/requests', friendController.getFriendRequests);

module.exports = router;


const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User');

const Chat = sequelize.define('Chat', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: false, // T√™n cu·ªôc tr√≤ chuy·ªán kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng
  },
  createdBy: {
    type: DataTypes.INTEGER,
    allowNull: false, // ID c·ªßa ng∆∞·ªùi t·∫°o cu·ªôc tr√≤ chuy·ªán
    references: {
      model: 'Users',
      key: 'id'
    },
    onDelete: 'SET NULL', // N·∫øu ng∆∞·ªùi t·∫°o b·ªã x√≥a, tr∆∞·ªùng n√†y s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t th√†nh NULL
  },
  createdAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Chats', // T√™n b·∫£ng trong c∆° s·ªü d·ªØ li·ªáu
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
Chat.belongsTo(User, { foreignKey: 'createdBy', as: 'creator' });

module.exports = Chat;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const ChatMember = sequelize.define('ChatMember', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Chats',
      key: 'id',
    },
    onDelete: 'CASCADE', // X√≥a t·∫•t c·∫£ c√°c th√†nh vi√™n khi cu·ªôc tr√≤ chuy·ªán b·ªã x√≥a
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'CASCADE', // X√≥a th√†nh vi√™n khi ng∆∞·ªùi d√πng b·ªã x√≥a
  },
  joinedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'ChatMembers',
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
ChatMember.belongsTo(Chat, { foreignKey: 'chatId' });
ChatMember.belongsTo(User, { foreignKey: 'userId' });

module.exports = ChatMember;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const Document = sequelize.define('Document', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Chats',
      key: 'id',
    },
    onDelete: 'CASCADE', // X√≥a t√†i li·ªáu khi cu·ªôc tr√≤ chuy·ªán b·ªã x√≥a
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
  filePath: {
    type: DataTypes.STRING(255),
    allowNull: false,
  },
  uploadedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Documents',
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
Document.belongsTo(Chat, { foreignKey: 'chatId' });
Document.belongsTo(User, { foreignKey: 'userId' });

module.exports = Document;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User'); // Import model User

const Friend = sequelize.define('Friend', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users',
      key: 'id',
    },
  },
  friend_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users',
      key: 'id',
    },
  },
  status: {
    type: DataTypes.STRING,
    allowNull: false,
    defaultValue: 'pending',
  },
  nick_name: {
    type: DataTypes.STRING,
    allowNull: true,
  },
  created_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  updated_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'Friends',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
Friend.belongsTo(User, { foreignKey: 'user_id', as: 'userDetail' });
Friend.belongsTo(User, { foreignKey: 'friend_id', as: 'friendDetail' });


module.exports = Friend;
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Chat = require('./Chat');
const User = require('./User');

const Message = sequelize.define('Message', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  chatId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Chats', // T√™n b·∫£ng cu·ªôc tr√≤ chuy·ªán
      key: 'id', // Kh√≥a ch√≠nh trong b·∫£ng chats
    },
    onDelete: 'CASCADE', // X√≥a t·∫•t c·∫£ tin nh·∫Øn khi cu·ªôc tr√≤ chuy·ªán b·ªã x√≥a
  },
  senderId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'Users', // T√™n b·∫£ng ng∆∞·ªùi d√πng
      key: 'id', // Kh√≥a ch√≠nh trong b·∫£ng users
    },
    onDelete: 'SET NULL', // ƒê·∫∑t gi√° tr·ªã senderId th√†nh NULL n·∫øu ng∆∞·ªùi d√πng b·ªã x√≥a
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false, // N·ªôi dung tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng
  },
  timestamp: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW, // M·∫∑c ƒë·ªãnh l√† th·ªùi ƒëi·ªÉm hi·ªán t·∫°i
  },
}, {
  tableName: 'Messages', // T√™n b·∫£ng trong c∆° s·ªü d·ªØ li·ªáu
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
Message.belongsTo(Chat, { foreignKey: 'chatId' });
Message.belongsTo(User, { foreignKey: 'senderId', as: 'sender' });

module.exports = Message;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const User = require('./User');

const Room = sequelize.define('Room', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  roomCode: {
    type: DataTypes.STRING(20),
    allowNull: false,
    unique: true, // ƒê·∫£m b·∫£o roomCode l√† duy nh·∫•t
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: true, // T√™n ph√≤ng c√≥ th·ªÉ ƒë·ªÉ tr·ªëng
  },
  createdAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
  createdBy: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'SET NULL',
  },
}, {
  tableName: 'Rooms',
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
Room.belongsTo(User, { foreignKey: 'createdBy' });

module.exports = Room;
const { DataTypes } = require('sequelize');
const sequelize = require('../database/db');
const Room = require('./Room');
const User = require('./User');

const RoomMember = sequelize.define('RoomMember', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
  },
  roomId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Rooms',
      key: 'id',
    },
    onDelete: 'CASCADE', // X√≥a t·∫•t c·∫£ th√†nh vi√™n khi ph√≤ng b·ªã x√≥a
  },
  userId: {
    type: DataTypes.INTEGER,
    references: {
      model: 'Users',
      key: 'id',
    },
    onDelete: 'CASCADE', // X√≥a th√†nh vi√™n khi ng∆∞·ªùi d√πng b·ªã x√≥a
  },
  joinedAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
  },
}, {
  tableName: 'RoomMembers',
  timestamps: true,
});

// Thi·∫øt l·∫≠p m·ªëi quan h·ªá
RoomMember.belongsTo(Room, { foreignKey: 'roomId' });
RoomMember.belongsTo(User, { foreignKey: 'userId' });

module.exports = RoomMember;
const {DataTypes} =require('sequelize');
const sequelize=require('../database/db')


// Dinh nghia model User anh xa voi bang User

const User=sequelize.define('User',{
    id:{
        type:DataTypes.INTEGER,
        primaryKey:true,
        autoIncrement:true
    },
    username:{
        type:DataTypes.STRING,
        allowNull:false,

    },
    email:{
        type:DataTypes.STRING,
        allowNull:false,
        unique:true,
        validate:{
            isEmail:true
        }

    },
    password:{
        type:'users',
        allowNull: false
    },
     
},
{
    tableName: 'Users',
    timestamps: true  
}
    
);
module.exports=User;
migration

'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      username: {
        type: Sequelize.STRING
      },
      email: {
        type: Sequelize.STRING
      },
      password: {
        type: Sequelize.STRING
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Users');
  }
};


'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Chats', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        type: Sequelize.STRING(100),
        allowNull: false
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      createdBy: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Chats');
  }
};

'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Messages', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      senderId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      timestamp: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Messages');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('ChatMembers', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      joinedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      unique: {
        type: Sequelize.STRING,
        unique: true,
        fields: ['chatId', 'userId']
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('ChatMembers');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Rooms', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      roomCode: {
        type: Sequelize.STRING(20),
        allowNull: false,
        unique: true
      },
      name: {
        type: Sequelize.STRING(100)
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      createdBy: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Rooms');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('RoomMembers', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      roomId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Rooms',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      joinedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      unique: {
        type: Sequelize.STRING,
        unique: true,
        fields: ['roomId', 'userId']
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('RoomMembers');
  }
};



'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Documents', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      chatId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Chats',
          key: 'id'
        },
        onDelete: 'CASCADE'
      },
      userId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Users',
          key: 'id'
        },
        onDelete: 'SET NULL'
      },
      filePath: {
        type: Sequelize.STRING(255),
        allowNull: false
      },
      uploadedAt: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Documents');
  }
};
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('Friends', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Users', // T√™n b·∫£ng m√† b·∫°n mu·ªën li√™n k·∫øt
          key: 'id'  // Kh√≥a ch√≠nh c·ªßa b·∫£ng Users
        },
        onDelete: 'CASCADE', // N·∫øu ng∆∞·ªùi d√πng b·ªã x√≥a, c√°c b·∫£n ghi b·∫°n b√® s·∫Ω b·ªã x√≥a theo
      },
      friend_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'Users', // T√™n b·∫£ng m√† b·∫°n mu·ªën li√™n k·∫øt
          key: 'id'  // Kh√≥a ch√≠nh c·ªßa b·∫£ng Users
        },
        onDelete: 'CASCADE', // N·∫øu ng∆∞·ªùi b·∫°n b·ªã x√≥a, c√°c b·∫£n ghi li√™n quan c≈©ng s·∫Ω b·ªã x√≥a
      },
      status: {
        type: Sequelize.STRING,
        allowNull: false, // B·∫Øt bu·ªôc
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP') // M·∫∑c ƒë·ªãnh l√† th·ªùi ƒëi·ªÉm hi·ªán t·∫°i
      },
      nick_name: {
        type: Sequelize.STRING, // T√™n hi·ªÉn th·ªã c·ªßa ng∆∞·ªùi b·∫°n
        allowNull: true, // C√≥ th·ªÉ ƒë·ªÉ tr·ªëng
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP') // C·∫≠p nh·∫≠t th·ªùi gian
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('Friends'); // X√≥a b·∫£ng Friends n·∫øu c√≥
  }
};
const Chat = require('../models/Chat'); // Import model Chat
const Message = require('../models/Message'); // Import model Message
const User = require('../models/User'); // Import model User
const Friend = require('../models/Friend'); // Import model Friend
const ChatMember = require('../models/ChatMember'); // Import model ChatMember

const chatController = {
  // T·∫°o cu·ªôc tr√≤ chuy·ªán gi·ªØa 2 ng∆∞·ªùi d√πng ƒë√£ k·∫øt b·∫°n
  createChat: async (req, res) => {
    try {
      const { userId1, userId2 } = req.body; // userId1 v√† userId2 l√† ID c·ªßa 2 ng∆∞·ªùi d√πng

      // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ k·∫øt b·∫°n ch∆∞a
      const friendRelation = await Friend.findOne({
        where: {
          user_id: userId1,
          friend_id: userId2,
          status: 'accepted'
        }
      });

      if (!friendRelation) {
        return res.status(400).json({ message: 'These users are not friends' });
      }

      // T·∫°o cu·ªôc tr√≤ chuy·ªán m·ªõi
      const chat = await Chat.create({
        name: `Chat between ${userId1} and ${userId2}`,
        createdBy: userId1 // C√≥ th·ªÉ l·∫•y ID c·ªßa ng∆∞·ªùi t·∫°o cu·ªôc tr√≤ chuy·ªán
      });

      // Th√™m c√°c th√†nh vi√™n v√†o cu·ªôc tr√≤ chuy·ªán
      await ChatMember.create({ chatId: chat.id, userId: userId1 });
      await ChatMember.create({ chatId: chat.id, userId: userId2 });

      res.status(201).json({ message: 'Chat created successfully', chat });
    } catch (error) {
      console.error('Error creating chat:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // G·ª≠i tin nh·∫Øn v√†o cu·ªôc tr√≤ chuy·ªán
  sendMessage: async (req, res) => {
    try {
      const { chatId, senderId, content } = req.body;

      // Ki·ªÉm tra xem ng∆∞·ªùi g·ª≠i c√≥ ph·∫£i l√† th√†nh vi√™n c·ªßa cu·ªôc tr√≤ chuy·ªán kh√¥ng
      const chatMember = await ChatMember.findOne({
        where: { chatId, userId: senderId }
      });

      if (!chatMember) {
        return res.status(403).json({ message: 'You are not a member of this chat' });
      }

      // T·∫°o tin nh·∫Øn m·ªõi
      const newMessage = await Message.create({
        chatId,
        senderId,
        content,
      });

      res.status(201).json({ message: 'Message sent successfully', message: newMessage });
    } catch (error) {
      console.error('Error sending message:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // L·∫•y t·∫•t c·∫£ tin nh·∫Øn trong cu·ªôc tr√≤ chuy·ªán
  getMessages: async (req, res) => {
    try {
      const { chatId } = req.params;

      // L·∫•y t·∫•t c·∫£ tin nh·∫Øn theo chatId
      const messages = await Message.findAll({
        where: { chatId },
        include: [{ model: User, as: 'sender', attributes: ['id', 'username'] }],
        order: [['timestamp', 'ASC']], // S·∫Øp x·∫øp theo th·ªùi gian
      });

      res.status(200).json(messages);
    } catch (error) {
      console.error('Error fetching messages:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // L·∫•y t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán c·ªßa ng∆∞·ªùi d√πng
  getUserChats: async (req, res) => {
    try {
      const { userId } = req.params;

      const chats = await Chat.findAll({
        include: [
          {
            model: ChatMember,
            as: 'chatMembers',
            where: { userId }, // S·ª≠a l·∫°i ƒë·ªÉ ch·ªâ ƒë·ªãnh ƒë√∫ng userId
          },
        ],
      });

      res.status(200).json(chats);
    } catch (error) {
      console.error('Error fetching user chats:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },
};

module.exports = chatController;


controller/friendController.js
const Friend = require('../models/Friend');
const User = require('../models/User');

const friendController = {
  // G·ª≠i y√™u c·∫ßu k·∫øt b·∫°n
  sendFriendRequest: async (req, res) => {
        try {
            const { userId, friendId } = req.body;
            console.log('Received userId:', userId);
            console.log('Received friendId:', friendId);

            // Ki·ªÉm tra n·∫øu y√™u c·∫ßu ƒë√£ t·ªìn t·∫°i
            const existingRequest = await Friend.findOne({
                where: { user_id: userId, friend_id: friendId }
            });

            if (existingRequest) {
                console.log('Friend request already exists');
                return res.status(400).json({ message: 'Friend request already exists' });
            }

            // T·∫°o y√™u c·∫ßu k·∫øt b·∫°n m·ªõi
            await Friend.create({ user_id: userId, friend_id: friendId, status: 'pending' });
            res.status(201).json({ message: 'Friend request sent' });
        } catch (error) {
            console.error('Error sending friend request:', error);
            res.status(500).json({ message: 'Internal server error' });
        }
    },


  // Ch·∫•p nh·∫≠n y√™u c·∫ßu k·∫øt b·∫°n
  acceptFriendRequest: async (req, res) => {
    try {
      const { userId, friendId } = req.body;

      // T√¨m y√™u c·∫ßu k·∫øt b·∫°n v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh 'accepted'
      const friendRequest = await Friend.findOne({
        where: { user_id: friendId, friend_id: userId, status: 'pending' }
      });

      if (!friendRequest) {
        return res.status(404).json({ message: 'Friend request not found' });
      }

      friendRequest.status = 'accepted';
      await friendRequest.save();

      // T·∫°o quan h·ªá b·∫°n b√® ng∆∞·ª£c l·∫°i (c·∫£ hai ph√≠a)
      await Friend.create({ user_id: userId, friend_id: friendId, status: 'accepted' });

      res.status(200).json({ message: 'Friend request accepted' });
    } catch (error) {
      console.error('Error accepting friend request:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },

  // T·ª´ ch·ªëi y√™u c·∫ßu k·∫øt b·∫°n
  declineFriendRequest: async (req, res) => {
    try {
      const { userId, friendId } = req.body;

      // T√¨m y√™u c·∫ßu k·∫øt b·∫°n v√† x√≥a n√≥
      const friendRequest = await Friend.findOne({
        where: { user_id: friendId, friend_id: userId, status: 'pending' }
      });

      if (!friendRequest) {
        return res.status(404).json({ message: 'Friend request not found' });
      }

      await friendRequest.destroy();
      res.status(200).json({ message: 'Friend request declined' });
    } catch (error) {
      console.error('Error declining friend request:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  },


// L·∫•y danh s√°ch b·∫°n b√®
getFriendsList: async (req, res) => {
  try {
    const { userId } = req.query;

    const friends = await Friend.findAll({
      where: { user_id: userId, status: 'accepted' },
      include: [
        { model: User, as: 'friendDetail', attributes: ['id', 'username', 'email'] }
      ]
    });

    res.status(200).json(friends);
  } catch (error) {
    console.error('Error fetching friends list:', error);
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
},



  

  // L·∫•y danh s√°ch y√™u c·∫ßu k·∫øt b·∫°n
  getFriendRequests: async (req, res) => {
    try {
      const { userId } = req.query; // L·∫•y userId t·ª´ query params
  
      // Ki·ªÉm tra n·∫øu userId t·ªìn t·∫°i
      if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
      }
  
      const requests = await Friend.findAll({
        where: { friend_id: userId, status: 'pending' },
        include: [{ model: User, as: 'userDetail', attributes: ['id', 'username', 'email'] }],
      });
  
      res.status(200).json(requests);
    } catch (error) {
      console.error('Error fetching friend requests:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  }
  
};

module.exports = friendController;

userController.js
const bcrypt = require('bcrypt');
const User = require('../models/User');
const { json } = require('sequelize');
const jwt = require('jsonwebtoken');  // S·ª≠ d·ª•ng JWT ƒë·ªÉ t·∫°o token


const userController = {
    createUser: async (req, res) => {
        try {
            const { username, email, password } = req.body;

            // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i hay ch∆∞a
            const existingUser = await User.findOne({ where: { email } });
            if (existingUser) {
                return res.status(400).json({ message: "Email is already registered" });
            }

            // Hash m·∫≠t kh·∫©u tr∆∞·ªõc khi l∆∞u
            const hashedPassword = await bcrypt.hash(password, 10);

            // T·∫°o ng∆∞·ªùi d√πng m·ªõi
            const newUser = await User.create({
                username,
                email,
                password: hashedPassword // S·ª≠ d·ª•ng hashed password
            });

            res.status(201).json({
                message: "User created successfully",
                user: newUser
            });

        } catch (error) {
            console.error("Error creating user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    getAllUsers: async (req, res) => {
        try {
            const users = await User.findAll(); // Th√™m await ƒë·ªÉ ch·ªù k·∫øt qu·∫£
            res.status(200).json(users);

        } catch (error) {
            console.error("Error fetching users:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    getUserById: async (req, res) => {
        try {
            const userId = req.params.id;
            const user = await User.findByPk(userId); // Th√™m await

            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            res.status(200).json(user);
        } catch (error) {
            console.error("Error fetching user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    updateUser: async (req, res) => {
        try {
            const userId = req.params.id;
            const { username, email, password } = req.body;

            // Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ t·ªìn t·∫°i kh√¥ng
            const user = await User.findByPk(userId);
            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
            user.username = username || user.username;
            user.email = email || user.email;

            if (password) {
                const hashedPassword = await bcrypt.hash(password, 10);
                user.password = hashedPassword; // C·∫≠p nh·∫≠t password ƒë√£ ƒë∆∞·ª£c hash
            }

            await user.save();

            res.status(200).json({
                message: "User updated successfully",
                user
            });

        } catch (error) {
            console.error("Error updating user:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },

    deleteUser: async (req, res) => {
        try {
            const userId = req.params.id;

            // Ki·ªÉm tra ng∆∞·ªùi d√πng c√≥ t·ªìn t·∫°i hay kh√¥ng
            const user = await User.findByPk(userId);
            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // X√≥a ng∆∞·ªùi d√πng
            await user.destroy();

            res.status(200).json({ message: "User deleted successfully" });

        } catch (error) {
            console.error("Error deleting user", error);
            res.status(500).json({ message: "Internal server error" });
        }
    },
    loginUser:async (req,res)=>{
        try {
            const {email,password}=req.body;

            const user=await User.findOne({where:{email}});
            if(!user){
                return res.status(400).json({message:"User not found"});
            }

            const validPassword=await bcrypt.compare(password,user.password);
            if(!validPassword){
                return res.status(400).json({message:"Invalid email or password"})

            }
            
            const token=jwt.sign(
                { id: user.id, email: user.email },
                process.env.JWT_SECRET,  // Kh√≥a b√≠ m·∫≠t ƒë·ªÉ m√£ h√≥a JWT (c·∫ßn thi·∫øt l·∫≠p trong .env)
                { expiresIn: '1h' } 
            )

            res.status(200).json({
                message:'Login successful',
                token,
                user:{
                    id:user.id,
                    username:user.username,
                    email:user.username
                }
            });
        } catch (error) {
            console.error('Error logging in:',error)
            res.status(500).json({message:"Internal server erorr"});
        }
    }
};

module.exports = userController;